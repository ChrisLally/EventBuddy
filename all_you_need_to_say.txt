You are an expert in programming blockchain,
here is the polkadot Wiki,
use it to help me get answers to my questions)


# Polkadot and Kusama Wiki

## Basics

### Learn Staking Advanced

://polkadot.network/staking/). Discover the new
Staking Dashboard that makes staking much easier and
check this
extensive article list to
help you get started. You can now stake on
 natively with just


and earn staking rewards. For additional information, check out
this blog post.

://paritytech.github.io/substrate/master/pallet_bags_list/) is named as
'voterList'.

For a demo about bags list see this video tutorial.

://github.com/paritytech/substrate/pull/9507).
 The
Bags-List substrate pallet is designed to be self-maintaining, with minimal effort from the
blockchain, making it extremely scalable. The bags list has two primary components, bags and nodes
(or nominators' accounts), with bags containing the nodes with bonded balance within a specific
range. In the figure below the 1st empty bag will contain nominators whose bonded balance is in the
range of 21 - 30 DOT, the 2nd bag 11 - 20 DOT, and the 3rd bag 0-10 DOT. The nomination intents are
the nominators' accounts with bonded tokens (in the example shown below, there are eight nomination
intents) that will be put inside each of those three bags depending on their stake.

!bags list example 0

The bags list is semi-sorted, meaning that sorting is only partially done. When the nomination
intents are submitted to the network, they are automatically put into each bag based on the number
of bonded tokens, but within each bag, those nodes are arranged based on the time they are inserted
and not based on their stake (see figure below). When the nomination intent of 19 DOT is submitted,
it gets placed at the last spot in the 2nd bag (shown in the yellow circle). The same scenario
applies for the node with 8 DOT (green circle) in the 3rd bag. Placing the node above all nodes with
a lesser stake requires an additional step (more on this later).

!bags list example 1

The mentioned two nodes (19 DOT and 8 DOT) have the option to move up in their respective bags,
which can put them in front of the nodes with less stake than them (see figure below). This action
must be done manually by submitting the `putInFrontOf` extrinsic within the `voterList` pallet
instance. Moreover, if the node with 19 DOT bonds an additional 2 DOT, that node will be put
automatically in the 1st bag (i.e. automatic `rebag`) because the total number of bonded tokens will
now be within the range of the 1st bag. That node with now 21 DOT will be put at the tail end of the
1st bag with the possibility to manually put itself in front of "older" nodes with less than 21 DOT
(if there are any).

!bags list example 2

If one decides to send staking rewards to the stash account and automatically bond them (i.e.
compounding the staking rewards), the position within a bag does not change automatically. The same
scenario applies to a slashing event, i.e., when a nominator gets slashed, their position within a
bag does not change. This might result in a scenario where the node is in the wrong bag and needs to
be placed in the right bag. To address this issue, any account on-chain can submit the
permissionless extrinsic `rebag` within the `voterList` pallet instance to update the positions of
the nodes that do not belong to their bag and place them in the correct one. To reiterate, actions
like bonding/unbonding tokens automatically rebag the nominator node, but events like staking
rewards/slashing do not. See the bags-list section for more
information.

The bags-list is capable of including an unlimited number of nodes, subject to the chain's runtime
storage. In the current staking system configuration, the bags list keeps


nomination intents, of which, at most
come out as the electing nominators. See
Staking Election Stages section for more info.

This means that only a portion of the nomination intents is kept. Once the nomination period ends,
the NPoS election system takes all nomination intents and their associated votes as input, and it
outputs a set of validators. The bags are iterated from the most staked to the least staked. If the
accounts are not appropriately sorted, this could leave the last touched bag to only be partially
iterated. Thus, in some edge cases, the order of the members within a bag is important. Continuing
with the example used in the previous figures, there are 8 nomination intents of which only 7 will
be kept. If the bags list stays semi-sorted (i.e. no accounts call the `putInFrontOf` and `rebag`
extrinsics), the nomination of the node with 8 DOT in the 3rd bag will not be considered while that
of the preceding node with 5 DOT will be. Nomination of the node with 8 DOT will be kept only if it
puts itself in front of the one with 5 DOT. Note how the nomination of the node with 19 DOT in the
2nd bag will be considered regardless of changing its position inside the bag. The sorting
functionality of nomination intents using bags is extremely important for the
long-term improvements of the
staking/election system.

!bags list example 3

://research.web3.foundation/en/latest/polkadot/NPoS.html).

## Rewards Distribution

: once in commission fees for validating (if their commission
rate is above 0%), and once for nominating itself with own stake.

The following example should clarify the above. For simplicity, we have the following assumptions:

- These validators do not have a stake of their own.
- They each receive the same number of era points.
- There are no tips for any transactions processed.
- They do NOT charge any commission fees.
- Total reward amount is 100 DOT tokens.
- The current minimum amount of DOT to be a validator is 350 (note that this is _not_ the actual
  value, which fluctuates, but merely an assumption for purposes of this example; to understand how
  the actual minimal stake is calculated, see
  here).

|               | **Validator A** |                             |         |
| :-----------: | :-------------: | :-------------------------: | :-----: |
| Nominator (4) |   Stake (600)   | Fraction of the Total Stake | Rewards |
|      Jin      |       100       |            0.167            |  16.7   |
|    **Sam**    |       50        |            0.083            |   8.3   |
|     Anson     |       250       |            0.417            |  41.7   |
|     Bobby     |       200       |            0.333            |  33.3   |

|               | **Validator B** |                             |         |
| :-----------: | :-------------: | :-------------------------: | :-----: |
| Nominator (4) |   Stake (400)   | Fraction of the Total Stake | Rewards |
|     Alice     |       100       |            0.25             |   25    |
|     Peter     |       100       |            0.25             |   25    |
|     John      |       150       |            0.375            |  37.5   |
|   **Kitty**   |       50        |            0.125            |  12.5   |

_Both validators A & B have 4 nominators with a total stake 600 and 400 respectively._

Based on the above rewards distribution, nominators of validator B get more rewards per DOT than
those of validator A because A has more overall stake. Sam has staked 50 DOT with validator A, but
he only gets 8.3 in return, whereas Kitty gets 12.5 with the same amount of stake.

To estimate how many tokens you can get each month as a nominator or validator, you can use this
tool as a reference and play around with
it by changing some parameters (e.g. how many days you would like to stake with your DOT, provider
fees, compound rewards, etc.) to have a better estimate. Even though it may not be entirely accurate
since staking participation is changing dynamically, it works well as an indicator.

#### Commission Fees & Slashes

The network slashes a validator for a misbehavior. The slashed amount is a fixed percentage (and not
a fixed amount), which means that validators with more stake get slashed more DOT. Again, this is
done to provide nominators with an economic incentive to shift their preferences and back less
popular validators whom they consider to be trustworthy.

Also, note that each validator candidate is free to name their desired commission fee (as a
percentage of rewards) to cover operational costs. Since validators are paid the same, validators
with lower commission fees pay more to nominators than validators with higher fees. Thus, each
validator can choose between increasing their fees to earn more, or decreasing their fees to attract
more nominators and increase their chances of being elected. In the long term, we expect that all
validators will need to be cost-efficient to remain competitive, and that validators with higher
reputation will be able to charge slightly higher commission fees (which is fair).

## Slashing

### Equivocation

**GRANDPA Equivocation**: A validator signs two or more votes in the same round on different chains.

**BABE Equivocation**: A validator produces two or more blocks on the Relay Chain in the same time
slot.

Both GRANDPA and BABE equivocation use the same formula for calculating the slashing penalty:

    Let x = offenders, n = total no. validators in the active set

    min( (3 * x / n )^2, 1)

As an example, assume that there are 100 validators in the active set, and one of them equivocates
in a slot (for our purposes, it does not matter whether it was a BABE or GRANDPA equivocation). This
is unlikely to be an attack on the network, but much more likely to be a misconfiguration of a
validator. The penalty would be min(3 \* 1 / 100)^2, 1) = 0.0009, or a 0.09% slash for that
validator (i.e., the stake held by the validator and its nominators).

Now assume that there is a group running several validators, and all of them have an issue in the
same slot. The penalty would be min((3 \* 5 / 100)^2, 1) = 0.0225, or a 2.25% slash. If 20
validators equivocate, this is a much more serious offense and possibly indicates a coordinated
attack on the network, and so the slash will be much greater - min((3 \* 20 / 100)^2, 1) = 0.36, or
a 36% slash on all of these validators and their nominators. All slashed validators will also be
chilled.

From the example above, the risk of nominating or running many validators in the active set are
apparent. While rewards grow linearly (two validators will get you approximately twice as many
staking rewards as one), slashing grows exponentially. A single validator equivocating causes a
0.09% slash, two validators equivocating does not cause a 0.09 \* 2 = 0.18% slash, but rather a
0.36% slash - 4x as much as the single validator.

Validators may run their nodes on multiple machines to make sure they can still perform validation
work in case one of their nodes goes down, but validator operators should be extremely careful in
setting these up. If they do not have good coordination to manage signing machines, equivocation is
possible.

If a validator is reported for any one of the offenses they will be removed from the validator set
(chilled) and they will not be paid while they are out. They will be considered
inactive immediately and will lose their nominators. They need to re-issue intent to validate and
again gather support from nominators.

### Slashing Across Eras

There are 3 main difficulties to account for with slashing in NPoS:

- A nominator can nominate multiple validators and be slashed via any of them.
- Until slashed, the stake is reused from era to era. Nominating with N coins for E eras in a row
  does not mean you have N\*E coins to be slashed - you've only ever had N.
- Slashable offenses can be found after the fact and out of order.

To balance this, we only slash for the maximum slash a participant can receive in some time period,
rather than the sum. This ensures protection from overslashing. Likewise, the period over which
maximum slashes are computed is finite and the validator is chilled with nominations withdrawn after
a slashing event, as stated in the previous section. This prevents rage-quit attacks in which, once
caught misbehaving, a participant deliberately misbehaves more because their slashing amount is
already maxed out.

## Simple Payouts

 makes stakers claim their rewards for
past eras by submitting a transaction. This naturally leads to spreading out reward distribution, as
people make transactions at disparate times, rather than updating the accounts of all stakers in a
single block.

Even if everyone submitted a reward claim at the same time, the fact that they are individual
transactions would allow the block construction algorithm to process only a limited number per block
and ensure that the network maintains a constant block time. If all rewards were sent out in one
block, this could cause serious issues with the stability of the network.

Simple payouts require one transaction per validator, per era, to
claim rewards. The reason  requires
this is to avoid an attack where someone has several thousand accounts nominating a single
validator. The major cost in reward distribution is mutating the accounts in storage, and
 cannot pay out several thousand
accounts in a single transaction.

### Claiming Rewards

 stores the last 84 eras of reward
information (e.g. maps of era number to validator points, staking rewards, nomination exposure,
etc.). Rewards will not be claimable more than 84 eras after they were earned. This means that all
rewards must be claimed within a maximum of 84 eras, although under certain circumstances (described
below) this may be as low as 28 eras.

If a validator kills their stash, any remaining rewards will no longer be claimable. Before doing
this, however, they would need to first stop validating and then unbond the funds in their stash,
which takes 28 eras. If a validator were to immediately chill and start unbonding after rewards are
calculated, and nobody issued a payout for that era from that validator in the next 28 eras, the
reward would no longer be claimable.

://docs.substrate.io/reference/how-to-guides/offchain-workers/) to compute
the result and submit a transaction to propose the set of winners. This can also be delegated to
stand-alone programs, whose task is to mine the optimal solution. Staking miners compete with each
other to produce election solutions which consist of a validator set, stake distribution across that
set, and a score indicating how optimal the solution is. Staking miners run any given staking
algorithms (as of now, sequential Phragmén or PhragMMS, subject to change if improved algorithms are
introduced) to produce results, which are then sent as a transaction to the relay chain via a normal
signed extrinsic. The transaction requires a bond and a transaction fee. The best solution is
rewarded, which the least covers the transaction fee, and the bond is returned to the account.
The bond and the fee are lost if the
solution is invalid.

Staking miner uses a pallet called `pallet_election_provider_multi_phase` and can only produce
solutions during the
`SignedPhase`
of the pallet's life cycle. Once the `SignedPhase` is over and the
`UnsignedPhase`
starts, only the off-chain workers can provide election results.

Running the staking miner requires passing the seed of a funded account in order to pay the fees for
the transactions that will be sent. The same account's balance is used to reserve deposits as well.
The best solution in each round is rewarded. All correct solutions will get their deposit back and
the ones that submit invalid solutions will lose their deposit.

### NPoS election optimization

!NPoS election optimization

A basic election solution is a simple distribution of stake across validators, but this can be
optimized for better distribution equaling a higher security score. The staking miner does not act
as a validator and focuses solely on the election result and optimization of the solution. It
connects to a specified chain and keeps listening to new signed phase of the election pallet in
order to submit solutions to the NPoS election. When the correct time comes, it computes its
solution and submits it to the chain. The default miner algorithm is sequential Phragmén with a
configurable number of balancing iterations that improve the score.

### Signed Phase of the election pallet

The election provider pallet `pallet_election_provider_multi_phase` is divided into two phases,
**signed** and **unsigned**. At the end of the pallet's timeline, the function `elect()` is called.

```
                                                                   elect()
                +     +     +
  +-------------------------------------------------------------------+
   Phase::Off   +       Phase::Signed     +      Phase::Unsigned      +
```

Solutions provided by the staking miner can only be submitted during the signed phase. Solutions are
submitted and queued on the chain as a `RawSolution`. Once submitted, a solution cannot be retracted
by the originating account.

`RawSolution` struct definition:

```
pub struct RawSolution {
    pub solution: S, // The solution itself
    pub score: ElectionScore, // The claimed score of the solution.
    pub round: u32, // The round at which this solution should be submitted.
}
```

A maximum of `pallet::Config::SignedMaxSubmissions` will be stored on-chain and they will be sorted
based on score. Higher the score the more optimal the election solution is. On both Polkadot and
Kusama the
'SignedMaxSubmissions'
is set to


submissions. This variable can be modified if needed through governance.

Upon arrival of a new solution:

1. If the queue is not full, it is stored in the appropriate sorted index.
2. If the queue is full but the submitted solution is better than one of the queued ones, the worse
   solution is discarded, the deposit of the outgoing solution is returned, and the new solution is
   stored in the correct index.
3. If the queue is full and the solution is not an improvement compared to any of the queued ones,
   it is instantly rejected and no deposit is reserved.

Upon the end of the `SignedPhase`, no more solutions can be submitted and the solutions in the queue
will be checked using
`Pallet::feasibility_check`
which ensures the score is indeed correct, and marks them as valid or invalid. By checking each
solution in the queue, the queue will be reorganized by score. The highest valid score will be
rewarded. Invalid solutions with higher score than the winning solution will be slashed. The rest of
the solutions will be discarded and their deposit will be returned. Once the staking miner with a
winning solution is ready to be rewarded the runtime will automatically execute
`finalize_signed_phase_accept_solution`
which reward account associated with the winning solution.

```
Queue
+-------------------------------+
|Solution(score=20, valid=false)| +-->  Slashed
+-------------------------------+
|Solution(score=15, valid=true )| +-->  Rewarded, Saved
+-------------------------------+
|Solution(score=10, valid=true )| +-->  Discarded
+-------------------------------+
|Solution(score=05, valid=false)| +-->  Discarded
+-------------------------------+
|             None              |
+-------------------------------+
```

### Deposit and reward mechanics

The staking miners are required to pay a deposit to post their solutions. Deposit amount is the sum
of `SignedDepositBase` +`SignedDepositByte` + `SignedDepositWeight`. All good solutions are subject
to receiving a `SignedRewardBase`.

#### Deposit

Current deposit(`SignedDepositBase`) is


which is a fixed amount.

Current deposit per byte(`SignedDepositByte`) is


and the total is variable depending on the size of the solution data. For example, a solution
weighing 200KB would yield


And the weight deposit(`SignedDepositWeight`) is currently set to `0` and has no effect.

#### Reward

Current reward(`SignedRewardBase`) is


which is a fixed amount.

### Further Resources

If you want to run a staking miner on your validator, refer to the repository provided in the
resources section below.

- Staking Miner repository
- Election Pallet definition
- Signed phase parameter configuration on Polkadot

### Learn Guides Staking



### Learn Staking

://www.polkadot.network/ecosystem/wallets/) and start your staking journey
or explore more information about staking on
Polkadot's Staking Page. Discover the new
Staking Dashboard that makes staking much easier and
check this
extensive article list to
help you get started. The dashboard supports Ledger devices natively and
does not require an extension or wallet as an interface.

://polkadot.network/blog/nomination-pools-are-live-stake-natively-with-just-1-dot/).
Check the wiki doc on nomination pools for more information.

:

- **Block production**, i.e. the way multiple blocks candidates are produced, and
- **Block finality**, i.e. the way only one block out of many candidates is selected and added to
  the canonical chain (see this article
  for more information about finality).

Proof-of-Work (PoW) and Proof-of-Stake (PoS) are well-known mechanisms used to reach consensus in a
secure and trustless way on public blockchains, where there are many participants who do not know
each other (and probably never will). In PoW, network security relies on the fact that the miners
who are responsible for adding blocks to the chain must compete to solve difficult mathematic
puzzles to add blocks - a solution that has been criticized for the wastage of energy. For doing
this work, miners are typically rewarded with tokens.

In PoS networks like  the security of
the network depends on the amount of capital locked on the chain: the more the capital locked, the
lower the chance of an attack on the network, as the attacker needs to incur a heavy loss to
orchestrate a successful attack (more on this later on). The process of locking tokens on the chain
is called **staking**.

Similar to the miners in PoW networks, PoS networks have **validators**, but they do not have to
compete with each other to solve mathematical puzzles. They are instead pre-selected to produce the
blocks based on the stake backing them. Token holders can lock funds on the chain and for doing so,
they are getting **staking rewards**. There is thus an economic incentive for token holders to
become active participants who contribute to the economic security and stability of the network. PoS
networks in general are therefore more inclusive than PoW networks, as participants do not need to
have either technical knowledge about blockchain technology or experience in running mining
equipment.

PoS ensures that everybody participating in the staking process has "skin in the game" and thus can
be held accountable. In case of misbehavior, participants in the staking process can be punished or
**slashed**, and depending on the gravity of the situation, their stake can be partly or fully
confiscated by the network. It is not in a staker's economic interest to orchestrate an attack and
risk losing tokens. Any rational actor staking on the network would want to get rewarded, and the
PoS network rewards good behavior and punishes bad behavior.

## Nominated Proof-of-Stake (NPoS)

 implements
Nominated Proof-of-Stake (NPoS), a relatively novel
and sophisticated mechanism to select the validators who are allowed to participate in its
consensus protocol. NPoS encourages
 holders to participate as **nominators**.

Any potential validators can indicate their intention to be a validator candidate. Their candidacies
are made public to all nominators, and a nominator, in turn, submits a list of up to
  candidates that it supports, and the network
will automatically distribute the stake among validators in an even manner so that the economic
security is maximized. In the next era, a certain number of validators having the most
 backing get elected and become active. For
more information about the election algorithm go to this page on the wiki or
this research article. As a
nominator, a minimum of


is required to submit an intention to nominate, which can be thought of as registering to be a
nominator. Note that in NPoS the stake of both nominators and validators can be slashed. For an
in-depth review of NPoS see
this research article.

:

- Locking tokens on-chain.
- Selecting a set of validators, to whom these locked tokens will automatically be allocated to.

How many tokens you lock up is completely up to you - as are the validators you wish to select. The
action of locking tokens is also known as **bonding**. You can also refer to your locked tokens as
your bonded tokens, or staked tokens. Likewise, selecting validators is also known as backing or
nominating validators. These terms are used interchangeably by the community. From now on locked
tokens will be referred to as bonded tokens.

Once the previous 2 steps are completed and you are nominating, your bonded tokens could be
allocated to one or more of your selected validators, and this happens every time the active
validator set changes. This validator set is updated every era on
.

Unlike other staking systems,
automatically chooses which of your selected validators will be backed by your bonded tokens.
Selecting a group of validators increases your chances of consistently backing at least one who is
active. This results in your bonded tokens being allocated to validators more often, which means
more network security and more rewards. This is in strong contrast to other staking systems that
only allow you to back one validator; if that validator is not active, you as a staker will also not
be. 's nomination model solves this.

 uses tools ranging from election
theory to game theory to discrete optimization, to develop an efficient validator selection process
that offers fair representation and security, thus avoiding uneven power and influence among
validators. The election algorithms used by
 are based on the Proportional
Justified Representation (PJR) methods like Phragmen. For more information
about PJR methods visit this
research article.

### Eras and Sessions

The stake from nominators is used to increase the number of tokens held by such candidates,
increasing their chance of being selected by the election algorithm for block production during a
specific **era**. An era is a period of  hours
during which an **active set** of validators is producing blocks and performing other actions on the
chain. This means that not all validators are in the active set and such set changes between eras.
Each era is divided into 6 epochs or **sessions** during which validators are assigned as block
producers to specific time frames or **slots**. This means that validators know the slots when they
will be required to produce a block within a specific session, but they do not know all the slots
within a specific era. Having sessions adds a layer of security because it decreases the chance of
having multiple validators assigned to a slot colluding to harm the network.

### Staking Rewards

Validators who produce a block are rewarded with tokens, and they can share rewards with their
nominators. Both validators and nominators can stake their tokens on chain and receive staking
rewards at the end of each era. The staking system pays out rewards equally to all validators
regardless of stake. Thus, having more stake in a validator does not influence the amount of block
rewards it receives. This avoids the centralization of power to a few validators. There is a
probabilistic component in the calculation of rewards, so they may not be exactly equal for all
validators. In fact, during each era validators can earn **era points** by doing different tasks on
chain. The more the points, the higher the reward for a specific era. This promotes validators'
activity on chain. To know more about era points, and how and on which basis they are distributed
visit the dedicated page. Distribution of the
rewards is pro-rata to all stakers after the validator's commission is deducted.

### Skin in the game when Staking

The security of PoS networks depends on the amount of staked tokens. To successfully attack the
network, a malicious actor would need to accrue a large number of tokens or would need different
participants to collude and act maliciously. If there is an attack in the case of NPoS, both the
validator(s) and nominators will be slashed resulting in their stake being partially or fully
confiscated by the network and then deposited to the treasury. There is little interest for a
rational network participant to act in a harmful way because NPoS ensures that all participants can
be held accountable for their bad actions. In NPoS, validators are paid equal rewards regardless of
the amount of stake backing them, thus avoiding large payouts to few large validators which might
lead to centralization.

## Being a Nominator

### Tasks and Responsibilities of a Nominator

**Validators.** Since validator slots are limited, most of those who wish to stake their
 and contribute to the economic security of
the network will be nominators, thus here we focus on the role of nominators. However, it is worth
mentioning that validators do most of the heavy lifting: they run the validator nodes and manage
session keys, produce new block
candidates in BABE, vote and come to consensus in
GRANDPA, validate the state transition function of
parachains, and possibly some other responsibilities regarding data availability and
XCM. For more information, you can take a look at the
validator docs to understand what you need to do as a validator. If you want
to become a validator you can consult
this guide.

**Nominators.** Nominators have far fewer responsibilities than validators. These include selecting
validators and monitoring their performance, keeping an eye on changing commission rates (a
validator can change commission at any time), and general health monitoring of their validators'
accounts. Thus, while not being completely set-it-and-forget-it, a nominator's experience is
relatively hands-off compared to that of a validator, and even more with
nomination pools. For more information, you can take a look at the
nominator guide to understanding your responsibilities as a nominator.

If you want to become a nominator, see this guide. If you are a
beginner and would like to securely stake your tokens using the Polkadot-JS UI, refer to
this
support article.


://staking.polkadot.network/dashboard/#/overview) provides a more
user-friendly alternative to staking. See the instructions in
this
support article to learn how to stake with the dashboard.

:

- recent history of the era points earned across eras
- validator's self stake (shows skin in the game)
- total stake backing the validator (which is the sum of self stake and the stake coming from
  nominators)
- commission fees (i.e. how much validators charge nominators)
- verified identity
- previous slashes

The diagram below shows how the selection of those criteria affects the reward-to-risk ratio.

!rewards and risks diagram

#### Validator Selection Criteria

To maximize rewards and minimize risk, one could select those validators that:

- have era points above average (because they will get more rewards for being active),
- have the total stake backing the validator below the average active validator stake (because they
  will pay out more rewards per staked ),
- have high own stake (because if slashed they have something to lose),
- have low commission fees but not 0% (because it makes sense that for doing the heavy lifting,
  validators ask for a small commission),
- have on-chain registered identity (because it adds a layer of trust and possibly provides access
  to their website and contact details),
- and have not been slashed (meaning that their on-chain behavior is genuine).

#### Network Providers

For successful operation, a Validator node should always be ensured to meet the required
software, hardware, and network bandwidth specifications.
Understandably, most of the validator nodes run on cloud service providers that guarantee high
hardware specifications and high levels of availability and connectivity. Keep in mind that a
validator in the active set is supposed to be fully online and available for producing blocks. If
the active validator node goes offline due to network interruptions or a power outage, that
validator will get fewer rewards.

://polkawatch.app/). The app will
show your rewards earned in the past 60 eras divided by network provider and country. You will be
able to see networks used by each validator and verify if your validators are using providers who
support PoS. This is also a great tool to explore how decentralized your nominations are and act
accordingly.

://polkadot.js.org/apps/#/staking) to know which
validator is producing blocks for the relay chain or parachains.

It is not recommended to change nominations because of the low era points of a validator in a single
era. Variability in rewards due to the era points should level out over time. If a validator
consistently gets era points below average, it makes sense to nominate a better-performing validator
for the health of the network and increased staking rewards. See
this
support article to understand in detail how to select the set of validators to nominate.

### Stash Account and Staking Proxy

Two different accounts can be used to securely manage your funds while staking.

- **Stash:** This account holds funds bonded for staking, but delegates all staking functions to a
  staking proxy account. You may actively participate in staking with a stash private key kept in a
  cold wallet like Ledger, meaning it stays offline all the time. Having a staking proxy will allow
  you to sign all staking-related transactions with the proxy instead of using your Ledger device.
  This will allow you:

  - to avoid carrying around your Ledger device just to sign staking-related transactions, and
  - to and to keep the transaction history of your stash clean

- **Staking Proxy:** This account acts on behalf of the stash account, signalling decisions about
  nominating and validating. It can set preferences like commission (for validators) and the staking
  rewards payout account. The earned rewards can be bonded (locked) immediately for bonding on your
  stash account, which would effectively compound the rewards you receive over time. You could also
  choose to have them deposited to a different account as a free (transferable) balance. If you are
  a validator, it can also be used to set your session keys. Staking
  proxies only need sufficient funds to pay for the transaction fees.

://www.subwallet.app/download.html) and
Talisman extension. Users can import their Ledger accounts in the extension
and use them as a stash in staking. You can find more information about SubWallet, Talisman and
other wallets that officially secured funding from the treasury
here.

: Note that Kusama runs approximately 4x as fast as Polkadot, except for block production times.
Polkadot will also produce blocks at approximately six-second intervals. :kusama }}

Rewards are calculated per era (approximately six hours on Kusama and twenty-four hours on
Polkadot). These rewards are calculated based on era points, which have a probabilistic component.
In other words, there may be slight differences in your rewards from era to era, and even amongst
validators in the active set at the same time. These variations should cancel out over a long enough
timeline. See the page on Validator Payout Guide.

The distribution of staking rewards to the nominators is not automatic and needs to be triggered by
someone. Typically the validators take care of this, but anyone can permissionlessly trigger rewards
payout for all the nominators whose stake has backed a specific validator in the active set of that
era. Staking rewards are kept available for 84 eras. The following calculation can be used to
approximate this length in days on :




For more information on why this is so, see the page on simple payouts.

://polkadot.js.org/apps/#/staking), you will see a
list of all validators that you have nominated in the past 84 eras and for which you have not yet
received a payout. The payout page is visible only to stakers.

Each validator as well as their nominators have the option to trigger the payout for all unclaimed
eras. Note that this will pay everyone who was nominating that validator during those eras.
Therefore, you may not see anything in this tab, yet still have received a payout if somebody
(generally, but not necessarily, another nominator or the validator operator) has triggered the
payout for that validator for that era.

://support.polkadot.network/support/solutions/articles/65000168954-how-can-i-see-my-staking-rewards-)
for details. For specific details about validator payouts, please see
this guide.

### Slashing

Slashing will happen if a validator misbehaves in the network. They and their nominators will get
slashed by losing a percentage of their bonded/staked DOT.

Any slashed DOT will be added to the Treasury. The rationale for this
(rather than burning or distributing them as rewards) is that slashes may then be reverted by the
Council by simply paying out from the Treasury. This would be useful in situations such as faulty
slashes. In the case of legitimate slashing, it moves tokens away from malicious validators to those
building the ecosystem through the normal Treasury process.

Validators with a larger total stake backing them will get slashed more harshly than less popular
ones, so we encourage nominators to shift their nominations to less popular validators to reduce
their possible losses.

It is important to realize that slashing only occurs for active validations for a given nominator,
and slashes are not mitigated by having other inactive or waiting nominations. They are also not
mitigated by the validator operator running separate validators; each validator is considered its
own entity for purposes of slashing, just as they are for staking rewards.

In rare instances, a nominator may be actively nominating several validators in a single era. In
this case, the slash is proportionate to the amount staked to that specific validator. With very
large bonds, such as parachain liquid staking accounts, a nominator has multiple active nominations
per era (Acala's LDOT nominator typically has 7-12 active nominations per era). Note that you cannot
control the percentage of stake you have allocated to each validator or choose who your active
validator will be (except in the trivial case of nominating a single validator). Staking allocations
are controlled by the Phragmén algorithm.

Once a validator gets slashed, it goes into the state as an "unapplied slash". You can check this
via
Polkadot-JS UI.
The UI shows it per validator and then all the affected nominators along with the amounts. While
unapplied, a governance proposal can be made to reverse it during this period
(
days). After the grace period, the slashes are applied.

The following levels of offense are
defined. However, these
particular levels are not implemented or referred to in the code or in the system; they are meant as
guidelines for different levels of severity for offenses. To understand how slash amounts are
calculated, see the equations in the section below.

- Level 1: Isolated equivocation, slashes a very small
  amount of the stake.
- Level 2: misconducts unlikely to be accidental, but which do not harm the network's security to
  any large extent. Examples include concurrent equivocation or isolated cases of unjustified voting
  in GRANDPA. Slashes a moderately small amount of the stake and chills.
- Level 3: misconduct that poses serious security or monetary risk to the system, or mass collusion.
  Slashes all or most of the stake behind the validator and chills.

If you want to know more details about slashing, please look at our
research page.

### Chilling

Chilling is the act of stepping back from any nominating or validating. It can be done by a
validator or nominator at any time, taking effect in the next era. It can also specifically mean
removing a validator from the active validator set by another validator, disqualifying them from the
set of electable candidates in the next NPoS cycle.

Chilling may be voluntary and validator-initiated, e.g. if there is a planned outage in the
validator's surroundings or hosting provider, and the validator wants to exit to protect themselves
against slashing. When voluntary, chilling will keep the validator active in the current session,
but will move them to the inactive set in the next. The validator will not lose their nominators.

When used as part of a punishment (initiated externally), being chilled carries an implied penalty
of being un-nominated. It also disables the validator for the remainder of the current era and
removes the offending validator from the next election.

 allows some validators to be
disabled, but if the number of disabled validators gets too large,
 will trigger a new validator election
to get a full set. Disabled validators will need to resubmit their intention to validate and
re-garner support from nominators.

For more on chilling, see the "How to Chill" page on
this wiki.

### Fast Unstake

://staking.polkadot.network/#/overview) will automatically check if you
qualify. For more information, visit the
"Fast Unstake" section in this support article.

## Why and Why not to Stake?

### Pros of Staking

- Earn rewards for contributing to the network's security through staking.
- Low barrier of entry through Nomination Pools.
- Can choose up-to   validators which can help
  to decentralize the network through the sophisticated
  NPoS system
- 10% inflation/year of the tokens is primarily intended for staking rewards.

When the system staking rate matches with the ideal staking rate, the entire inflation of the
network is given away as the staking rewards.

The ideal staking rate is a dynamic value - as the number of active parachains influences the
available liquidity that is available to secure the network.

Any divergence from the ideal staking rate will result in the distribution of a proportion of the
newly minted tokens through inflation to go to the treasury. Keep in mind that when the system's
staking rate is lower than the ideal staking rate, the annual nominal return rate will be higher,
encouraging more users to use their tokens for staking. On the contrary, when the system staking
rate is higher than the ideal staking rate, the annual nominal return will be less, encouraging some
users to withdraw. For in-depth understanding, check the
inflation section on the Wiki.

### Cons of Staking

- Tokens will be locked for about

  days on  No rewards will be earned
  during the unbonding period.
- Possible punishment in case of the active validator found to be misbehaving (see
  slashing).
- Lack of liquidity i.e. You would not be able to use the tokens for participating in crowdloans or
  transfer them to different account etc.

#### Unbonding Period Length

The unbonding period provides a safety net for slashing offenses identified in
past eras,
which can hold the respective validators and their nominators accountable. The
-day
unbonding period is crucial in mitigating ex post facto slashing, particularly in guarding against
long-range attacks. When a client encounters a chain finalized by
GRANDPA that originates more than

days in the past, it lacks the security of slashing protection.

Essentially, this period establishes a cadence for synchronizing with the chain or acquiring a
checkpoint within a timeframe that engenders trust. It's worth noting that while the choice of a
-day
period is somewhat arbitrary, it unquestionably provides a higher level of security compared to a
shorter period.

## How many Validators?

 currently has


validators. The top bound on the number of validators has not been determined yet, but should only
be limited by the bandwidth strain of the network due to peer-to-peer message passing.




## Why am I not receiving rewards?

Nominating on  is not a set-and-forget
action. Nominators need to monitor their nominations and ensure they are eligible to receive staking
rewards. Otherwise, they would be risking their funds to secure the chain with no reward. If you are
bonding significantly more than the Minimum Active Bond and yet not receiving rewards, your
nominations are all waiting, or your active validator has 100% commission. However, if you bond
funds close to the Minimum Active Bond, there could be several possibilities for not receiving
staking rewards. The table below can be used to troubleshoot why you might not be receiving staking
rewards using Polkadot-JS UI.

|                   Nomination Status                   |                                                                                                                                               What's happening?                                                                                                                                                |                                                                                                                                                    Causes                                                                                                                                                    |                                                                                                                                                What to do?                                                                                                                                                |
| :---------------------------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|    Nominated validators are all in waiting status.    |                                                                                           Your stake has not been assigned to any of the nominated validators. You cannot earn rewards, nor be slashed in that era.                                                                                            |                                                                   Waiting validators are not in the active set in the current era and the stake backing them is not used to secure the network. In simple words, NPoS "does not see them".                                                                   |                                                                                    Change your nominations. Try to select validators (with reasonable commission) that have high chances to end up in the active set.                                                                                     |
| You have some inactive, and some waiting nominations. | Validators shown as "Inactive" in your staking dashboard are still in the active set and are producing blocks in the current era, but your stake has not been assigned to any of them. You will not earn rewards if your stake is not backing an active validator. In this case, you cannot be slashed either. | **Scenario 1:** You have bonded less than the Minimum Active Bond. **Scenario 2:** You have more than the Minimum Active Bond, but your account is at the tail end of the bags list and within your bag there are accounts with less stake than you, in front of you. | **Scenario 1:** Try bonding more funds. **Scenario 2:** Try to put your account in front of the accounts with less stake than you. Instructions available here |

://support.polkadot.network/support/solutions/articles/65000170805-why-am-i-not-getting-staking-rewards-)
and this video tutorial.

://support.polkadot.network/support/solutions/articles/65000181959-staking-faq-s)
for the FAQs about staking.

://medium.com/web3foundation/how-nominated-proof-of-stake-will-work-in-polkadot-377d70c6bd43) -
  Blog post by Web3 Foundation researcher Alfonso Cevallos covering NPoS in Polkadot.
- Validator setup
- Polkadot validator selector tool - A tool
  that helps nominators find reliable validators that meet quality-control criteria, including
  commission rates, verified identity, etc.

---

### Learn Guides Staking Pools

import MessageBox from
"../../components/MessageBox";



See this page to learn about nomination pools.

## Pool Creation with Polkadot-JS

://support.polkadot.network/support/solutions/articles/65000182388-staking-dashboard-how-to-create-a-nomination-pool#How-to-create-a-pool)
for more information.

://polkadot.js.org/apps/#/extrinsics) on Polkadot JS
Apps UI.

!Nomination Pool Roles

## Pool Upkeep with Polkadot-JS

The nominator can update the pool’s validator selection. On Polkadot JS Apps UI, navigate to
Network > Staking > Accounts page and click on
Pooled button. If you have any pooled accounts with the role of nominator, you will notice the
option to set nominees. Select the validators to nominate like you would normally using a nominator
account.

!Nominate validators

The root and bouncer can update the pool’s state to blocked through `setState` extrinsic and kick
members by calling `unbond` and `withdrawUnbonded`. (The state can also be toggled back to open).

## Pool Destruction with Polkadot-JS

://support.polkadot.network/support/solutions/articles/65000182388-staking-dashboard-how-to-create-a-nomination-pool#How-to-destroy-a-pool)
for more information.

:

- The root and bouncer set the pool to “destroying”. This can be done by submitting the
  `nominationPools.setState(poolId, state)` extrinsic using the
  Polkadot-JS UI extrinsic tab. Where `poolId` is the
  specific ID of the pool and `state` is the pool's state that must be set to "destroying". Other
  possible states are "open" and "blocked".
- Any account can set the pool to destroying if over 90% of the pool's active bonded balance has
  been slashed.

When a pool is in ‘destroying’ state, `unbond` and `withdrawUnbonded` become permissionless, so
anyone can help all the members exit.

The pool is destroyed once the depositor withdraws, no members belong to the pool, and all the
pool’s resources are wiped from the state.

## Claim Rewards for Other Pool Members with Polkadot-JS

As a pool member you can claim rewards for any other members who set their
claim permissions to one of the _permissionless_
options.

Let's take the example of ALICE setting the claim permissions to `PermissionlessAll`. Another
account STASH can now claim ALICE's rewards (as a free balance or compound them to the existing
bonded balance). To do so, STASH can go to the
Polkadot-JS UI Extrinsic Tab and issue the following
extrisics:

- `nominationPools.claimPayoutOthers` extrinsic specifying ALICE's account. This will claim the
  rewards as a free balance on ALICE's account.

!pools-payoutOthers

- `nominationPools.bondExtraOthers` extrinsic specifying ALICE's account and the option to bond:
  - the free balance currently available in ALICE's account (`FreeBalance`) or
  - the pool rewards (`Rewards`) unclaimed by ALICE.

!pools-bondExtraOthers

### Staking Dashboard

## Preliminary Notes

The Polkadot Staking Dashboard supports
**proxy accounts** and you can import your
staking proxy (for nominators) or
non-transfer proxy (for nomination pool admins and
members).

The dashboard also has **native Ledger support**, meaning that you do not need an
extension or a wallet to use it; you just need your Ledger device.
Metadata updates
are thus not necessary, as you only need to keep your Ledger apps up-to-date.

Before using the dashboard, make sure you have a
wallet or extension with a funded
 account. Note that accounts on
wallets or extensions can be imported from Ledger or
Polkadot Vault.

On top of the existential deposit, you
need some free balance to pay for transaction fees and the
minimum amount to place your nominations (only for nominators, currently
)
or join a nomination pool (only for pool members, currently
).
For more information about staking on
visit the staking page and the
advanced staking page.

## Using the Polkadot Staking Dashboard

The Polkadot Staking Dashboard is a tool only
dedicated to staking on Polkadot,
Kusama (Polkadot's canary network) and
Westend (Polkadot's test network).

The dashboard is not a wallet, meaning that you cannot transfer funds between accounts. To fund
accounts, you can use wallets and extension. You can participate in
staking by being a nominator or a member of a
nomination pool. Once you have a funded account, you need to
connect it to the dashboard (connect button on the top-right corner), this will allow you to
interact with  native staking.

://youtu.be/hvXLc4H7rA4).

://youtu.be/F59N3YKYCRs): Stake your tokens, choose your best validators,
  and start your staking journey on .
- **Becoming a Pool Member**: Start becoming a part of the Polkadot
  movement, keep  secure by staking
  minimum 1 DOT and receiving staking rewards.
- **Dashboard Walkthrough**: Become a Pro using the Staking
  Dashboard.
- **After Staking**: Nominating on
   is not a set-and-forget action,
  learn what you can do with the dashboard after you started staking.

://youtu.be/hvXLc4H7rA4) shows you everything you can do with the Staking
Dashboard.

:

- **Section A: The Sidebar** shows which page you are on (in this case, the Overview). It will also
  show the role you currently have in staking (in this case, active in both Pools and
  Nominate). You can also change the network (currently on Kusama).

- **Section B: The Accounts Panel** allows you to connect one account to the dashboard. Once
  connected, the account will appear next to the `Accounts` button. You can see it here if you are
  active as a nominator and/or a pool member. In this case, the account KSM Stash is a nominator and
  a member of the pool Insight Finance. Proxy accounts are also shown here if applicable. Note that
  the dashboard will automatically fetch the stash and the proxy.

Note that Sections A and B will always be visible while you use the dashboard.

- **Section C: The Stats Panel** shows the general view of current staking metrics, including the
  historical reward rate (including after
  inflation), the supply staked and time remaining
  in the current era.

- **Section D: The Summary Panel** shows your current situation and gives you general tips about
  staking. In this case, the KSM Stash account is a nominator and a pool member, and by clicking on
  `Manage >` you can go directly to the Nominate and Pools pages,
  respectively. You can take actions such as changing staking preferences, bonding more funds, etc.

- **Section E: The Balance Panel** shows the bonded amount distinguishing between "Nominating", "In
  a Pool", and "Not Staking". The amount that is not staking is further divided into "Free" (a
  balance that can be transferred) and "Reserve" (a balance that is needed the keep the account
  on-chain, see existential deposit).
  In this case, 0.301 KSM are bonded for nominating, 0.3 KSM are bonded in a pool, and 0.145 KSM are
  not used for staking. Of the non-staking balance, 0.144 KSM are free while

  are reserved for the existential deposit.

- **Section F: The Recent Payouts Panel** shows a bar chart with the rewards paid out to you in the
  past 15 days either as a nominator or a pool member (manually claimed). Note how the 4th of April
  bar has the tip that is not filled with color. This is to show a pending payout (for nominators
  only). Below the bar chart is a line chart showing the 10-day moving average.

Additional statistics can be found at the bottom of the overview page.

://youtu.be/dDIG7QAApig) shows you how to join a
nomination pool with the Staking Dashboard. You can also read
the
dedicated support article
about joining a pool.

:

- **Section A: The Stats Panel** shows the number of active pools and the minimum number of tokens
  needed to join a pool and/or create one.
- **Section B: The Balance Panel** shows the number of tokens bonded in pools and those that are
  free. In this case, we have 0.3 KSM bonded and 0.144 KSM free. In this panel, you can bond more
  funds (`+` button) or unbond some funds (`-` button). Unbonding will withdraw unclaimed rewards
  and funds will be locked for 28 eras
  (). Once the 28 eras have passed, you
  can unlock the locked funds (button with a lock icon) that will be available as a free balance.

: The Pool Panel** shows the pool id where you have membership (in this case, Pool 82),
  the pool name, and next to it, a `Manage` button that will allow to choose between different
  options:

  - Update Claim Permissions: you can allow other pool members to compound your rewards, withdraw
    your rewards as a free balance, or both. More details about nomination pools and updating claim
    permissions can be found on the
    dedicated wiki page.

  !dashboard-permissionlessPoolClaims

  ://support.polkadot.network/support/solutions/articles/65000182399-staking-dashboard-how-to-claim-nomination-pool-rewards#Permissionless-claiming).

  :

  - Claim Commission: you can claim pool commissions to an account specified under Manage Commission
    (below).
  - Manage Commission: you can manage the pool commission rate, maximum commission, maximum change
    rate, and minimum time delay between commission updates. More details about nomination pools and
    managing pool commissions can be found on the
    dedicated wiki page.

  !dashboard-manage-commission

  ://support.polkadot.network/support/solutions/articles/65000182388-staking-dashboard-how-to-create-a-nomination-pool#Pool-management-options).

  : you can change the pool's name.
  - Lock Pool: you can lock the pool so that new members are not allowed.
  - Destroy Pool: you can destroy the pool. See
    this wiki page and
    this support article
    for more information.

  You can see any unclaimed rewards in the middle of the panel. You can claim and bond the rewards
  (`+ Compound` button) or withdraw them as a free balance (`Withdraw` button). In this case, there
  are approximately 0.0012 KSM that can be claimed. You can see the Pool Status at the bottom of the
  panel, currently set to "Nominating and Earning Rewards".

Note that if it is the first time you log in to the dashboard, you will see two
buttons `Create` and `Join`, instead of `Manage`. For more information about how to create a
nomination pool, see
this support article.

- **Section D: The Pool Nominations Panel** shows the nominations of the pool you are currently in,
  highlighting the validator that is active and will pay rewards to the pool at the end of the era
  (in this case `ParaNodes.io/11`).

If you scroll down the page, there are two additional panels:

- **Roles** showing the accounts of the pool's Depositor, Root, Nominator, and Bouncer. The same
  account can cover all the roles.
- **Pool Stats** showing the Pool State (either Active, Closed, or Destroying), Pool Members (number
  of members in the pool), and Total Bonded (total number of bonded tokens).

The Pools page is divided into four parts: the Overview is basically what we talked about until now,
the Members section will show all accounts of the pool members, the All Pools section will show all
pools (you can filter Active, Locked, and Destroying pools), and the Favorites section shows all
pools that you liked (you can like a pool in the All Pools section by clicking on the heart icons).

### Nominate

://youtu.be/F59N3YKYCRs) shows you how to become a nominator with the
Staking Dashboard.

:

- **Section A: The Stats Panel** shows the number of active nominators, the minimum number of tokens
  to nominate (currently
  )
  and the minimum active bond (currently
  ).
  The system keeps 12500 nomination intents and puts them into the
  bags list. The fact that active nominators are not
  12500 is because there are nominators that have no active validator.
- **Section B: The Balance Panel** shows the number of tokens bonded in nominations and those that
  are free. In this case, we have 0.301 KSM bonded and 0.144 KSM free. In this panel, you can bond
  more funds (`+` button) or unbond some funds (`-` button). Unbonding will withdraw unclaimed
  rewards and funds will be locked for 28 eras
  (). Once the 28 eras have passed, you
  can unlock the locked funds (button with a lock icon) that will be available as a free balance.

: The Nominator Panel** shows the current status of the nominator, currently set to
  "Nominating and Earning Rewards", and next to it, the `Unstake` button allows you to unstake the
  whole bonded amount and stop nominating. In the middle of the panel, the payout destination is
  currently set to "Compounding" (i.e. rewards are added to the bonded funds). The `Update` button
  will allow you to change the destination to "To Your Account" (to the stash account as a free
  balance), "To Another Account" (an account that is not the stash), or "None" (no payout
  destination).
- **Section D: The Nominations panel** shows your nominations and allows you to stop all nomination
  with the `Stop` button or to select specific validators (`Select` button) and stop nominating only
  those.

### Payouts

This page is an expanded version of Panel F on the Overview page. It also shows all
validators and/or nomination pools that paid out rewards to your accounts in the past few months.

### After Staking

://youtu.be/F59N3YKYCRs) shows you how to what you can do after staking
with the Staking Dashboard.

:

- **Panel A: The Stats Panel** shows the total number of active validators, all validators currently
  registered (active and inactive), and average commission across all validators.
- **Panel B: The Validators Panel** shows all validators. You can order them by low/high commission
  or apply the following filters:
  - Include only active validators
  - Exclude validators that have 100% commission, blocked nominations, and have missing identity.

## Support

Support for the Staking Dashboard is available at
the official Polkadot support website.

## Network

Under Network, you can connect to either Polkadot, Kusama, or Westend through public RPC nodes or
light clients for a true Web3 experience. For more information about light clients, see
this page.

### Staking Apps

://github.com/w3f/polkadot-wiki#contributing-to-documentation)
and add your protocol native, permissionless, non-custodial NPoS Staking app to this page.

://staking.polkadot.network/#/overview) is a web3 application
dedicated to native non-custodial staking on the
 relay chain. The dashboard allows to
stake as a solo nominator or as a nomination pool member.
Users can also create their nomination pools. The dashboard supports Ledger,
Polkadot Vault,
SubWallet,
Talisman, WalletConnect, Fearless Wallet,
PolkaGate, and Enkrypt. The dashboard also supports
staking proxies.

You can find more information about the Polkadot staking dashboard on the dedicated
wiki page and
support articles.

Below a list of video tutorial about the Polkadot Staking Dashboard.







      Stake your DOT







      Join a Nomination Pool







      Staking Dashboard Walkthrough










      After Staking







      Create, Manage & Destroy Pools




## Sub.ID

Sub.ID is a one-stop-shop for managing your Polkadot accounts, viewing your
addresses and balances, and looking at other accounts. It features a Polkadot
staking page, where you can easily start staking
. Stakers can choose their preferred
validators or stake with the recommended validator set.

## NOMI

NOMI is designed to actively involve Nominators in Native
Staking within the  networks. It aims
to offer a unique and enhanced nomination experience, using
Multiple-Criteria Decision Analysis
(MCDA) as a base for the analytical research. MCDA is an open and transparent approach for
evaluating numerous conflicting traits in the decision-making process. For the analysis, validator
data is collected at the last block of every session.

![](https://turboflakes.io/)

source: https://github.com/turboflakes/apps

## SubWallet Earning

SubWallet Web Dashboard is the all-in-one solution to manage assets
and stake on multiple networks in the Polkadot, Kusama and Polkadot SDK (Substrate) ecosystems.

The Web Dashboard features an Earning tab which allows users to stake DOT easily via native
nomination pools, as well as in liquid staking and lending protocols, without having to manage
multiple applications with different interfaces and experiences.

### Learn Validator

://medium.com/@acvlls/setting-up-a-maintain-the-easy-way-3a885283091f)
- A Serverless Failover Solution for Web3.0 Validator Nodes -
  Blog that details how to create a robust failover solution for running validators.
- VPS list
- Polkadot Validator Lounge -
  A place to chat about being a validator.
- Slashing Consequences - Learn more about slashing consequences for
  running a validator node.
- Why You Should be A Validator on Polkadot and Kusama
- Roles and Responsibilities of a Validator
- Validating on Polkadot - An explanation of
  how to validate on Polkadot, with Joe Petrowski and David Dorgan of Parity Technologies, along
  with Tim Ogilvie from Staked.

### Security / Key Management

- Validator Security Overview

### Monitoring Tools

- PANIC for Polkadot - A monitoring and alerting
  solution for Polkadot / Kusama node
- Polkadot Telemetry Service - Network
  information, including what nodes are running on a given chain, what software versions they are
  running, and sync status.

### Validator Stats

- HashQuark Staking Strategy - The HashQuark
  staking strategy dashboard helps you choose the optimal set-up to maximize rewards, and provides
  other useful network monitoring tools.
- Polkastats - Polkastats is a cleanly designed dashboard for validator
  statistics.
- YieldScan - Staking yield maximization platform, designed to minimize
  effort.
- Subscan Validators Page - Displays information on the
  current validators - not as tailored for validators as the other sites.

### Thousand Validators

The Thousand Validators Programme is an initiative by Web3 Foundation and Parity Technologies to use
the funds held by both organizations to nominate validators in the community.

It serves two major purposes:

1. Give validators a structured on-ramp to join the active set of validators on Kusama and Polkadot
2. Further decentralize the validator active set.

## How it Works

The nominating backend will routinely change its
nominations at every . The backend does
this by short-listing candidates by validity and then sorts validators by their weighted score in
descending order.

- Validators with a higher weighted score are selected for any possible slots. As validators are
  nominated and actively validate, their weighted scores decrease allowing other validators to be
  selected in subsequent rounds of assessment.

- If a validator is active during a single nomination period (the time after a new nomination and
  before the next one) and does not break any of the requirements, it will have its rank increased
  by 1. Validators with higher rank have performed well within the program for a longer period of
  time.

The backend nominates as many validators as it reasonably can in such a manner to allow each nominee
an opportunity to be elected into the active set.

## Setting up a Validator

Please see the guide on how to
set up a validator as well as additional
information on how to secure a validator.

## How to Apply

{{ polkadot: **Entrance to the Polkadot program requires a rank of 25 or higher in the Kusama program.**
Attaining a rank of 25 usually takes around two months. The leaderboard is available
here.
In order to apply to the Polkadot 1KV programme, set up your Polkadot node to adhere to the requirements below
and fill in the application form. You will hear back from the team shortly. :polkadot }}

{{ kusama: In order to apply to the Kusama 1KV programme, set up your node to adhere to the requirements below
and fill in the application form. The process of review and addition is a manual one; you'll be invited to the 1KV Kusama channel and added to the leaderboard, if accepted. :kusama }}

#### Requirements

- Verified identity (see here for instructions)
- Connect to dedicated telemetry (use
  `--telemetry-url 'wss://telemetry-backend.w3f.community/submit 1'` when starting the node)
-
-
- Have a staking proxy set up
- Must be on the latest release
-
- Validators must operate nodes themselves. They may not be operated by third parties or staking
  providers.

#### Nominators

The below addresses are the stash / staking proxy pairs for the primary nominators involved in the
 Thousand Validators programme. They
are formatted like "`stash` / `staking proxy`".

















A time delay proxy is used as the interaction method for some of these accounts.



Since approximately early January 2021, the nominators will select an automatic number of validators
to nominate based on the lowest amount staked for a validator and the amount of funds it holds. This
can be anywhere from a few validators receiving nomination from a single nominator, to the max of
 nominators on
.

## Selection

On-chain parameters assess each candidate to produce a weighted score. It is a changing system in
which new endpoints or scores are sometimes introduced. Below are some of the original weights.

### Weights

#### Inclusion

The inclusion weight accounts for 40 points. It is assessed by an evaluation of the validator's
inclusion in the active set over the past 84 eras. A candidate can be assured of full score if there
were no stints of active validation in 84 eras.

#### Span Inclusion \*

The span inclusion weight accounts for 40 points. It is assessed by an evaluation of the validator's
inclusion in the active set over the past 28 eras. A candidate can be assured of full score if there
were no stints of active validation in 28 eras.

#### Discovered \*

The discovered weight accounts for 5 points. It is determined by comparing the candidates tenure in
the program relative to other candidates. A candidate that is in the program for a longer duration
relative to the entire group of validators allows for a higher score.

#### Nominated \*

The nominated weight accounts for 10 points, and it is assessed based on when the candidate was last
nominated relative to the other candidates in the program.

#### Rank \*

The rank weight accounts for 5 points and is assessed relative to the ranks of other candidates
within the program.

#### Unclaimed

The unclaimed weight relates to the number of payouts outstanding for greater than
 eras. Each payout that exceeds this
threshold would attribute a negative score of 10 points.

#### Bonded \*

Candidates with a bond size that is relatively higher than others would receive a score of 50
points.

#### Faults \*

A fault is attained when a candidate has an offline event when actively validating. A legitimate
fault is irrevocable. Faults account for 5 points in the system and are relative to others in the
program.

#### Offline time

Candidates who have accumulated  75% of their bond to the respective council members.

#### Democracy

Candidates will receive 10 \* 1KV points for each referendum they have voted on (Aye/Nay) to a limit
of 100 points. Scores are based on votes for referendum
 and beyond.

\* Scores that are based on their relative position against others are assessed as follows:

- The respective weight is assigned high and low percentiles. Any scores lower than the score at the
  low percentile and higher than the score at the high percentile are removed.
- The weighted score is then obtained by ((candidate_value - low_threshold) / (high_threshold -
  low_threshold)) \* weight.

* The default low and high percentiles are 10 and 90%, respectively.
* Inclusion and Span Inclusions are measured against low and high percentiles of 20 and 75%,
  respectively.
* Bonded is measured against low and high percentiles of 5 and 85%, respectively.
* Finally, location is measured against low and high percentiles of 10 and 95%, respectively.

## Frequently asked questions

- _How do I apply?_ See here.
- _How long does it take for the application to process?_ Usually a few weeks. Sometimes a little
  longer. You can inspect the candidate files
  here and see if your info shows
  up. Also, you will get invited to a dedicated matrix room after being accepted.
- _I'm in the program and am getting nominated but don't get active?_ The system optimizes the
  nominations to maximize the stake on active validators and minimize the stake variance across
  them. Also keep in mind that getting nominated does not mean all the nominations are with you.
  Nominators can choose up to 16 validators.
- _My scoring doesn't update_, _I haven't been elected for a while_? Sometimes it’s best to give
  things time to resolve; if they don't, leave a message in the dedicated matrix room or open an
  issue on GitHub.
- _The 1000 validators website is not up to date?_ See these resources for more
  up-to-date information.

## Resources

To extract and display the 1KV Programme scores there are various tools listed below.

| Resource                                                                                                                                    | Github source                                                                               | Info                                                                                                                           |
| ------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| Main 1KV site                                                                   | github                                           | Main site and 1KV backend.                                                                                                     |
| SubVT telegram bot for polkadot and kusama                              | github | Telegram bot with overviews and alerts for various polkadot and kusama related events, including 1KV events.                   |
| SubVT ios and android app                                                                                              | github                                         | SubVT app version for mobile phones.                                                                                           |
| Validator earnings overview                                                                                    | github                                                   | Overview of validators' earnings.                                                                                              |
| Math Crypto's Insights                                                                                 | github                                                  | 1KV-oriented scoring overview of Kusama and Polkadot.                                                                          |
| One-T for polkadot and kusama | github                                              | A performance report bot for the Polkadot and Kusama network with special focus on the 1KV programme.                          |
| One-T parachains overview                                                 | github                                              | One-T's parachain overview.                                                                                                    |
| Metaspan's 1KV overview                                                                             | github                                           | Overview of 1KV programme, including the newly introduced endpoints, see here for available endpoints. |
| Decentradot's 1KV overview                                                                                  | github                                                | Overview of the 1KV programme, including the newly introduced endpoints.                                                       |
| Hirish 1KV overview                                                                                       | github?                                                              | Overview of the 1KV Programme.                                                                                                 |

### Maintain Guides Validator Community

## Building a Community and Attracting Nominations

After setting up a validator, nominations will only come
in with extra work. The community of nominators will need to know about the validator to trust
staking with them, and thus the validator must distinguish themselves to attract nominations. The
following gives some general guidance on different approaches to building a community and attracting
nominations.

Being a high-quality validator entails effectively running nodes and building a brand, reputation,
and community around validation services. The responsibilities of a quality validator additionally
include marketing oneself and participating in the greater community. Becoming a known participant
throughout the ecosystem is a great way to attract nominations and solidify longevity and
sustainability as a validator.

One thing to remember is that there is a risk involved in staking for both validators and
nominators, as both can lose up to 100% of their funds if a validator gets slashed. This means it is
paramount for nominators only to nominate validators that they trust, as well as for validators to
do their best to instill confidence in their ability to provide validation services. Validators
should do their best to build a reputation through many different means, as this is one of the most
important factors in how nominators should pick whom they stake with.

## Gaining Visibility

Nominators should be able to know whom they are staking with. If nominators stake with a bunch of
pseudo-anonymous addresses because it seems profitable, they expose themselves to more risks than
nominating validators that follow best practices to whom they _know_ the addresses belong.
Establishing a clear identity in multiple places can help gain visibility across the ecosystem. This
includes setting an on-chain identity and making a known presence throughout various community
channels.

### Setting Identity

All validators should set an on-chain identity and
get a judgement on the identity so that nominators can find nodes when browsing through various
dashboards and UIs. When someone interacts with the chain, it ensures that an address they may come
across belongs to the validator, and actions of that identity throughout various parts of the
ecosystem (staking, governance, block explorers, etc.) form a cohesive representation of their
participation.

:

- staking-payouts
- substrate-payctl

### Validator Experience

### Architecture

One aspect of building trust is being transparent about your validator infrastructure. If nominators
know that you are running a tight ship that is focused on security, they are more likely to trust
you compared to those that do not disclose their infrastructure.

Some factors of architecture to highlight might include:

#### Servers

Outlining how a validator runs its servers helps nominators understand how diversified a validator
is. Does the Validator run in the cloud, on dedicated machines, in a co-located datacenter, or in a
home residential setup? Do they run multiple nodes on the same machine? If every validator is hosted
in AWS, there is a risk of potential outages that cause large amounts of nodes to go offline.
Nominators may want to choose validators that have thoroughly diversified the providers they use or
the facilities they operate in.

Additionally, how does a Validator contribute to decentralization? It can be helpful to outline
these efforts so that the values of a Nominator and Validator are aligned.

It's also helpful to outline what kind of OS is used on these servers and what is the updating
policy for the software on that OS. For example, are LTS versions used? Do they use NiXOS,
distro-packaged libraries? Any server hardening practices, etc.

#### Specs

Are you running the recommended Standard Hardware for
? Can you ensure that machines have
enough processing power, memory, file storage, and network connectivity? It's helpful for nominators
to know the specs of the machines a validator uses to assess how they may perform in the network. If
a validator is running underpowered machines, they may not want to nominate them, as these can
result in fewer blocks produced and fewer overall rewards. In certain circumstances, more powerful
machines can result in higher rewards for both the Validator and their Nominators.

#### Automation and orchestration approaches (Terraform, Ansible, Chef, Puppet, Kubernetes, etc.)

What kind of approach is taken for spinning up and provisioning nodes? How might you automate
spinning up large clusters of nodes and upgrading them? Elaborating on what type of automation (or
lack thereof) can help get a sense of how robust a validator setup is. Many everyday actions or
routine maintenance needs to be done, and automating this type of thing often helps mitigate human
errors.

#### Network Topology

Does the Validator node have protection against Denial of Service attacks, and if so, how is that
done? Outlining a desired network topology for a Validators infrastructure design will help
Nominators understand how resilient their operations are to attacks. Some things to highlight are
the usage of firewalls, VPNs, network segmentation, proxies, or other layers separation.

#### Upgrading

Both Polkadot and Kusama releases are published.
here. Validators are expected to upgrade
their nodes as soon as a new release comes. Although not every release is mandatory to upgrade, each
new release usually has bug fixes, optimizations, new features, or other beneficial changes. It's in
the best interest of the entire network that validators update their nodes in a timely fashion. This
signals to nominators that a validator is timely care about their operations and is quick to adapt
to necessary circumstances.

It can also be helpful for Nominators to know how the Validator runs software and where they get new
binaries. How do they get alerted for new releases? Do they receive updates from the matrix
chatrooms? Do they have alerts for particular GitHub activities? Do they use the Debian/RPM
packages? Do they use the Parity-provided GitHub binaries? Do they use Parity Docker images? Do they
make their own Docker images? Do they build the binaries themselves? Validators often have their own
build server for making binaries. If they take the extra steps to make these and do not rely on
external parties, this can be seen as a plus from nominators, as it helps contribute to
decentralization.

#### Logging, metrics, monitoring, and observability

Good node operators keep tabs on how their systems are running. Observability is one of the most
critical aspects of understanding the performance and behavior of a node. One should be able to
outline the efforts taken in building out monitoring and observability practices. Are Prometheus and
Grafana set up? What types of metrics are collected and looked at? How is this done across multiple
nodes? A quality validator may make these metrics and graphs public so that Nominators can see how
these nodes are running.

##### Health checks and alerting conditions

Similar to the last point, it can be helpful for nominators to know what kind of health checks and
alerting conditions are in place for validator nodes. What conditions are not typical and may need
to be looked at? If conditions are not specific, how is the node operator alerted to this? Are there
any public Telegram, SMS, or email alerts? Nominators will want to know that a Validator can respond
to abnormal conditions promptly, as their tokens are on the line of potentially being lost.

##### Scenario runbooks

Many scenarios happen routinely, such as upgrading nodes, restoring backups, or moving servers.
Creating runbooks and sharing the procedures and precautions taken around these can instill
confidence in nominators that various scenarios are thought out and planned for.

##### Which regions nodes are in

A diverse network of nodes in varying different regions helps strengthen decentralized networks.
Outlining what regions nodes are in gives clarity to this facet of networks. Nominators may want to
promote validators that actively try to decentralize networks operating in regions in which others
do not run nodes.

##### Security / Key handling policies

It is paramount that session keys and stash/staking proxy keys are stored and handled with the
utmost care. If compromised, both the validator and nominator can be slashed. Outlining how keys are
handled, how they are stored, who has access to them, and the overall policies and procedures around
them is a great point of reference for nominators to gauge how comfortable they are with the
security a validator takes.

### Robust Communication

The relationship between Validators and Nominators is one built on trust, and as such, having direct
lines of communication with Nominators is a great way to build and reinforce that trust. This could
mean setting up dedicated Telegram / Matrix / Discord channels or hosting a reoccurring call where
anyone can join. Creating inclusive environments with direct connections between parties is going
the extra mile to ensure that nominators know they're in good hands. Many updates can be given, such
as nodes being updated to a new version, rewards being paid out, servers being migrated, new
features or tools being built, or just checking in to say hello. These kinds of gestures can be much
appreciated in putting words and a person behind the name of someone running a server.

### Actively Participating in the Community

Participating in the community goes hand in hand with building a reputation. This is not only for
Nominators, but for other Validators, builders, developers, governance participants, and general
enthusiasts. Being helpful or contributing to discussions can go a long way in building a trusted
brand and reputation.

There are many communities to participate in, from validator, developer, and governance communities,
to local communities dedicated to specific regions. For example, one can be pretty active in the
South American communities and building camaraderie among those who speak the same language or can
attend the same meetups in an area. One absolute best way to build trust is meeting people in
person.

#### Participating in Governance

Another way to show that one cares about the network is by actively participating in governance.
Whether by voting on-chain, or by discussing off-chain, or proposing new things, active
participation in the direction of the chain is an excellent signal that a validator is there for the
network’s good. There are many ways to participate in different governance aspects, such as weighing
in on treasury proposals, voting on public referenda, delegating voting power, and more. See the
section on Polkadot OpenGov for additional details.

#### Producing Educational Content

With a fast-moving ecosystem, there often are gaps in educational content where there are new
features, changes, deprecations, or just a slow-moving process for putting out information about
very complex concepts. Putting out educational content in the form of blog posts, videos, tutorials,
development guides, and more (especially if it's geared toward nominators) provides tangible value
to the ecosystem. It shows that one has a good grasp of how things work, and disseminating this
knowledge to others can give some credence to one's brand and reputation as a competent entity in
the space. Furthermore, one might get tips from the treasury if the community finds something
beneficial.

#### Building Tooling

Building public tooling is a great way to support the ecosystem. This provides tangible value to
those that use this tooling and gives visibility to the validator for their contributions. A
nominator might be more likely to nominate a validator for the utilities they provide the ecosystem
since the validator then can build a reputation around the quality of their work outside their
validation services. Some potential building categories are block explorers, deployment scripts,
monitoring, observability services, staking dashboards, wallets, command-line utilities, or porting
implementations to other languages. Additionally, this may also be eligible to be funded via a
Web3 Foundation Grant.

### Maintain Guides Secure Validator

Validators in a Proof of Stake network are responsible for keeping the network in consensus and
verifying state transitions. As the number of validators is limited, validators in the set have the
responsibility to be online and faithfully execute their tasks.

This primarily means that validators:

- Must be high availability.
- Must have infrastructure that protects the validator's signing keys so that an attacker cannot
  take control and commit slashable behavior.

## High Availability

High availability set-ups that involve redundant validator nodes may seem attractive at first.
However, they can be **very dangerous** if they are not set up perfectly. The reason for this is
that the session keys used by a validator should always be isolated to just a single node.
Replicating session keys across multiple nodes could lead to equivocation slashes or parachain
validity slashes which can make you lose **100% of your staked funds**.

The good news is that 100% uptime of your validator is not really needed, as it has some buffer
within eras in order to go offline for a little while and upgrade. For this reason, we advise that
you only attempt a high availability set-up if **you're confident you know exactly what you're
doing.**

Many expert validators have made mistakes in the past due to the handling of session keys.

## Key Management

See the Polkadot Keys guide for more information on keys. The keys
that are of primary concern for validator infrastructure are the Session keys. These keys sign
messages related to consensus and parachains. Although Session keys are _not_ account keys and
therefore cannot transfer funds, an attacker could use them to commit slashable behavior.

Session keys are generated inside the node via RPC call. See the
How to Validate guide for
instructions on setting Session keys. These should be generated and kept within your client. When
you generate new Session keys, you must submit an extrinsic (a Session certificate) from your
staking proxy key telling the chain your new Session keys.

:

```
cat /boot/config-`uname -r` | grep CONFIG_SECCOMP=
```

The expected output, if enabled, is:

```
CONFIG_SECCOMP=y
```

3. OPTIONAL: **Linux 5.13**. Provides access to even more strict filesystem protections.

## Monitoring Tools

- Telemetry This tracks your node details
  including the version you are running, block height, CPU & memory usage, block propagation time,
  etc.

- Prometheus-based monitoring stack, including
  Grafana for dashboards and log aggregation. It includes alerting, querying,
  visualization, and monitoring features and works for both cloud and on-premise systems. The data
  from `substrate-telemetry` can be made available to Prometheus through exporters like
  this.

## Linux Best Practices

- Never use the root user.
- Always update the security patches for your OS.
- Enable and set up a firewall.
- Never allow password-based SSH, only use key-based access.
- Disable non-essential SSH subsystems (banner, motd, scp, X11 forwarding) and harden your SSH
  configuration
  (reasonable guide to begin with).
- Back up your storage regularly.

## Conclusions

- At the moment, Polkadot/Substrate can't interact with HSM/SGX, so we need to provide the signing
  key seeds to the validator machine. This key is kept in memory for signing operations and
  persisted to disk (encrypted with a password).

- Given that HA setups would always be at risk of double-signing and there's currently no built-in
  mechanism to prevent it, we propose having a single instance of the validator to avoid slashing.

### Validators

- Validators should only run the Polkadot binary, and they should not listen on any port other than
  the configured p2p port.

- Validators should run on bare-metal machines, as opposed to VMs. This will prevent some of the
  availability issues with cloud providers, along with potential attacks from other VMs on the same
  hardware. The provisioning of the validator machine should be automated and defined in code. This
  code should be kept in private version control, reviewed, audited, and tested.

- Session keys should be generated and provided in a secure way.

- Polkadot should be started at boot and restarted if stopped for any reason (supervisor process).

- Polkadot should run as a non-root user.

### Monitoring

- There should be an on-call rotation for managing the alerts.

- There should be a clear protocol with actions to perform for each level of each alert and an
  escalation policy.

## Resources

- Figment Network's Full Disclosure of Cosmos Validator Infrastructure
- Certus One's Knowledge Base
- EOS Block Producer Security List
- HSM Policies and the Important of Validator Security

### Maintain Guides Validator Payout

## Era Points

For every era (a period of time approximately 6 hours in length in Kusama, and 24 hours in
Polkadot), validators are paid proportionally to the amount of _era points_ they have collected. Era
points are reward points earned for payable actions like:

- issuing validity statements for parachain blocks.
- producing a non-uncle block in the Relay Chain.
- producing a reference to a previously unreferenced uncle block.
- producing a referenced uncle block.

://substrate.stackexchange.com/questions/5353/how-are-rewards-in-dot-calculated-from-the-era-points-earned-by-validators-in-po).

With parachains now on Polkadot, a large percentage of era points will come from parachain
validation, as a subset of validators are selected to para-validate for all parachains each epoch,
and those para-validators can generate more era points as a result. Para-validators are rewarded 20
era points each for each parachain block that they validate.

In this case, analyzing the _expected value_ of staking rewards will paint a better picture as the
weight of era points of validators and para-validators in the reward average are taken into
consideration.

:

- `pe` = para-validator era points,
- `ne` = non-para-validator era points,
- `EV` = expected value of staking rewards,

Then, `EV(pe)` has more influence on the `EV` than `EV(ne)`.

Since `EV(pe)` has a more weighted probability on the `EV`, the increase in variance against the
`EV` becomes apparent between the different validator pools (aka. validators in the active set and
the ones chosen to para-validate).

Also, let:

- `v` = the variance of staking rewards,
- `p` = number of para-validators,
- `w` = number validators in the active set,
- `e` = era,

Then, `v` &#8593; if `w` &#8593;, as this reduces `p` : `w`, with respect to `e`.

Increased `v` is expected, and initially keeping `p` &#8595; using the same para-validator set for
all parachains ensures
availability and
voting. In addition, despite `v` &#8593; on an `e` to `e`
basis, over time, the amount of rewards each validator receives will equal out based on the
continuous selection of para-validators.

There are plans to scale the active para-validation set in the future

: 4
Validator 1 Stake (v1): 18 tokens
Validator 2 Stake (v2):  9 tokens
Validator 3 Stake (v3):  8 tokens
Validator 4 Stake (v4):  7 tokens
Payout (p): 8 DOT

Payout for each validator (v1 - v4):
p / v = 8 / 4 = 2 tokens
```

Note that this is different than most other Proof-of-Stake systems such as Cosmos. As long as a
validator is in the validator set, it will receive the same block reward as every other validator.
Validator `v1`, who had 18 tokens staked, received the same reward (2 tokens) in this era as `v4`
who had only 7 tokens staked.

## Running Multiple Validators

It is possible for a single entity to run multiple validators. Running multiple validators may
provide a better risk/reward ratio. Assuming you have enough DOT, or enough stake nominates your
validator, to ensure that your validators remain in the validator set, running multiple validators
will result in a higher return than running a single validator.

For the following example, assume you have 18 DOT to stake. For simplicity's sake, we will ignore
nominators. Running a single validator, as in the example above, would net you 2 DOT in this era.

Note that while DOT is used as an example, this same formula would apply to KSM when running a
validator on Kusama.

```
Validator Set Size (v): 4
Validator 1 Stake (v1): 18 DOT  validator payment
(2 - 0.4) = 1.6 -> shared between all stake
(9 / 18) * 1.6 = 0.8 -> validator stake share
(9 / 18) * 1.6 = 0.8 -> nominator stake share
v1 validator total reward: 0.4 + 0.8 = 1.2 DOT
v1 nominator reward: 0.8 DOT

v2:
(0.4 * 2) = 0.8 DOT -> validator payment
(2 - 0.8) = 1.2 -> shared between all stake
(3 / 9) * 1.2 = 0.4 -> validator stake share
(6 / 9) * 1.2 = 0.8 -> nominator stake share
v2 validator total reward: 0.8 + 0.4 = 1.2 DOT
v2 nominator reward: 0.8 DOT

v3:
(0.1 * 2) = 0.2 DOT -> validator payment
(2 - 0.2) = 1.8 -> shared between all stake
(4 / 8) * 1.8 = 0.9 -> validator stake share
(4 / 8) * 1.8 = 0.9 -> nominator stake share
v3 validator total reward: 0.2 + 0.9 DOT = 1.1 DOT
v3 nominator reward: 0.9 DOT

v4:
(0 * 2) = 0 DOT -> validator payment
(2 - 0) = 2.0 -> shared between all stake
(1 / 6) * 2 = 0.33 -> validator stake share
(5 / 6) * 2 = 1.67 -> nominator stake share
v4 validator total reward: 0 + 0.33 DOT = 0.33 DOT
v4 nominator reward: 1.67 DOT
```

## Advanced Concepts

### Learn Xcm Pallet

://github.com/paritytech/polkadot-sdk/blob/master/polkadot/xcm/pallet-xcm/src/lib.rs))
provides a set of pre-defined, commonly used XCVM programs in the form of a set of extrinsics using
FRAME.

This pallet provides some default implementations for traits required by `XcmConfig`. The XCM
executor is also included as an associated type within the pallet's configuration.

Where the XCM format defines a set of instructions used to construct XCVM programs, `pallet-xcm`
defines a set of extrinsics that can be utilized to build XCVM programs, either to target the local
or external chains. `pallet-xcm`'s functionality is separated into three categories:

://github.com/paritytech/xcm-format). It is the job of the XCM executor is to
handle and execute these programs.

://github.com/paritytech/polkadot-sdk/blob/a808a3a0918ffbce314dbe00e03761e7a8f8ce79/polkadot/xcm/pallet-xcm/src/lib.rs#L902) -
   This call contains direct access to the XCM executor. It is the job of the executor to check the
   message and ensure that no barrier/filter will block the execution of the XCM. Once it is deemed
   valid, the message will then be _locally_ executed, therein returning the outcome as an event.
   This operation is executed on behalf of whichever account has signed the extrinsic. It's possible
   for only a partial execution to occur.
2. `send` -
   This call specifies where a message should be sent
   (via a transport method) externally to a particular destination, i.e.
   a parachain, smart contract, or any system which is governed by consensus. In contrast to
   `execute`, the executor is not called locally, as the execution will occur on the destination
   chain.

://github.com/paritytech/polkadot-sdk/blob/a808a3a0918ffbce314dbe00e03761e7a8f8ce79/polkadot/xcm/pallet-xcm/src/lib.rs#L872) -
   Transfer some assets from the local chain to the sovereign account of a destination chain and
   forward an XCM containing a
   `ReserveAssetDeposited`
   instruction, which serves as a notification.

2. `teleport_assets` -
   Teleport some assets from the local chain to some destination chain.

### Transfer Reserve vs. Teleport

While both extrinsics deal with transferring assets, they exhibit fundamentally different behavior.

- **Teleporting** an asset implies a two-step process: the assets are taken out of circulating
  supply (typically by burning/destroying) in the origin chain and re-minted to whatever account is
  specified at the destination. Teleporting should only occur if there is an inherent and bilateral
  trust between the two chains, as the tokens destroyed at the origin _could not_ necessarily be
  guaranteed to have the same properties when minted at the destination. There has to be **trust**
  that the a particular chain burned, or re-minted the assets.
- **Transferring** or **reserving** an asset implies that **equivalent** assets (i.e, native
  currency, like `DOT` or `KSM`) are withdrawn from _sovereign account_ of the origin chain and
  deposited into the sovereign account on the destination chain. Unlike teleporting an asset, it is
  not destroyed and re-minted, rather a trusted, third entity is used (i.e., Asset Hub) to
  **reserve** the assets, wherein the sovereign account of the destination chain on the reserve
  chain obtains ownership of these assets.

  It's worth noting that this means that some other mechanism is needed to ensure that the balance
  on the destination does not exceed the amount being held in reserve chain.

://github.com/paritytech/polkadot-sdk/blob/a808a3a0918ffbce314dbe00e03761e7a8f8ce79/polkadot/xcm/pallet-xcm/src/lib.rs#L934) -
   Modifies the `SupportedVersion` storage to change a particular destination's stated XCM version.
2. `force_default_xcm_version` -
   Modifies the `SafeXcmVersion` storage, which stores the default XCM version to use when the
   destination's version is unknown.
3. `force_subscribe_version_notify` -
   Sends an XCM with a
   `SubscribeVersion` instruction to a
   destination.
4. `force_unsubscribe_version_notify` -
   Sends an XCM with a
   `UnsubscribeVersion` instruction
   to a destination.

## Fees in the XCM Pallet

Message fees are only paid if the interior location does not equal the interpreting consensus system
(known as Here in the context of an XCM `Multilocation`). Otherwise, the chain bears the fees. If
applicable, fees are withdrawn from the assets from the specified `MultiLocation` and used as
payment to execute any subsequent instructions within the XCM.

Fees are generally dependent on several factors within the `XcmConfig`. For example, the barrier may
negate any fees to be paid at all.

Before any XCM is sent, and if the destination chain’s barrier requires it, a
`BuyExecution` instruction is used to buy
the necessary weight for the XCM. XCM fee calculation is handled by the Trader, which iteratively
calculates the total fee based on the number of instructions.

The Trader used to calculate the weight (time for computation in consensus) to include in the
message. Fee calculation in XCM is highly configurable and, for this reason, subjective to whichever
configuration is in place.

### Learn Xcm Usecases

:
  - **Remote Transfers**: control an account on a remote chain, allowing the local chain to have an
    address on the remote chain for receiving funds and to eventually transfer those funds it
    controls into other accounts on that remote chain.
  - **Asset Teleportation**: movement of an asset happens by destroying it on one side and creating
    a clone on the other side.
  - **Reserve Asset Transfer**: there may be two chains that want to nominate a third chain, where
    one includes a native asset that can be used as a reserve for that asset. Then, the derivative
    form of the asset on each of those chains would be fully backed, allowing the derivative asset
    to be exchanged for the underlying asset on the reserve chain backing it.

Let's review two of these example asset transfer use cases: **Asset Teleportation** and **Reserve
Asset Transfer**.

### Asset Teleportation

An asset teleport operation from a single source to a single destination.

!Diagram of the usage flow while teleporting assets

1. InitiateTeleport

The source gathers the assets to be teleported from the sending account and takes them out of the
circulating supply, taking note of the total amount of assets that was taken out.

2. ReceiveTeleportedAsset

The source then creates an XCM instruction called `ReceiveTeleportedAssets` and puts the amount of
assets taken out of circulation and the receiving account as parameters to this instruction. It then
sends this instruction over to the destination, where it gets processed and new assets gets put back
into circulating supply accordingly.

3. DepositAsset

The destination then deposits the assets to the receiving account of the asset.

### Reserve Asset Transfer

When consensus systems do not have a established layer of trust over which they can transfer assets,
they can opt for a trusted 3rd entity to store the assets.

!xcm-reserve-asset-transfer

1. InitiateReserveWithdraw

The source gathers the derivative assets to be transferred from the sending account and burns them,
taking note of the amount of derivatives that were burned.

2. WithdrawAsset

The source sends a WithdrawAsset instruction to the reserve, instructing the reserve to withdraw
assets equivalent to the amount of derivatives burned from the source's sovereign account.

3. DepositReserveAsset

The reserve deposits the assets withdrawn from the previous step to the destination's sovereign
account, taking note of the amount of assets deposited.

4. ReserveAssetDeposited

The reserve creates a ReserveAssetDeposited instruction with the amount of assets deposited to the
destination's sovereign account, and sends this instruction onwards to the destination. The
destination receives the instruction and processes it, minting the derivative assets as a result of
the process.

5. DepositAsset

The destination deposits the derivative assets minted to the receiving account.

### Learn Xcm

:
HRMP and
VMP).

XCM has four high-level core design principles which it stands to follow:

1. **Asynchronous**: XCM messages in no way assume that the sender will be blocking on its
   completion.
2. **Absolute**: XCM messages are guaranteed to be delivered and interpreted accurately, in order
   and in a timely fashion. Once a message is sent, one can be sure it will be processed as it was
   intended to be.
3. **Asymmetric**: XCM messages, by default, do not have results that let the sender know that the
   message was received - they follow the 'fire and forget' paradigm. Any results must be separately
   communicated to the sender with an additional message back to the origin.
4. **Agnostic**: XCM makes no assumptions about the nature of the consensus systems between which
   the messages are being passed. XCM as a message format should be usable in any system that
   derives finality through consensus.

These four crucial design decisions allow for XCM messages to be a reliable yet convenient way to
properly convey the intentions from one consensus system to another without any compatibility
issues.

://github.com/paritytech/xcm-format) to view any RFCs that have been
submitted that would contribute to the next release.

://polkadot.network/cross-chain-communication) that is not
only conducted between chains, but also between smart contracts, pallets, bridges, and even sharded
enclaves like SPREE.

XCM cannot actually send messages between systems. It is a format for how message transfer should be
performed, similar to how RESTful services use REST as an architectural style of development, where
HTTP requests contain specific parameters to perform some action.

Similar to UDP, out of the box XCM is a "fire and forget" model, unless there is a separate XCM
message designed to be a response message which can be sent from the recipient to the sender. All
error handling should also be done on the recipient side.

:

1. **Programmability** - the ability to have **expectations** for messages, which allow for more
   comprehensive use cases, safe dispatches for version checking, branching, and NFT/Asset support.

2. **Functional Multichain Decomposition** - the ability to define mechanisms to cross-reference and
   perform actions on other chains on behalf of the origin chain (remote locking), context/id for
   these messages, and asset namespacing.

3. **Bridging** - introduces the concept of a universal location, which allows for a base reference
   for global consensus systems for multi-hop setups. This location is above the parent relay chain
   or other consensus systems like Ethereum or Bitcoin.

A core part of the vision that XCM provides is improving communication between the chains to make
**system parachains** a reality. For example, the Polkadot relay chain handles more than just
parachain management and shared security - it handles user balances/assets, auctions, governance,
and staking. Ideally, the relay chain should be for what it's intended to be - a place for shared
security. System parachains can alleviate these core responsibilities from the relay chain but only
by using a standard format like XCM.

This is where system parachains come in, where each of these core responsibilities can be delegated
to a system parachain respectively.

://github.com/paritytech/xcm-format).

## Resources

- Shawn Tabrizi: XCM - The Backbone Of A Multichain Future | Polkadot Decoded 2022 -
  High level overview which should answer “What is XCM?

- XCM: The Cross-Consensus Message Format -
  Detailed blog post by Dr. Gavin Wood about the XCM Format.

- XCM Format specification - The best starting point for
  understanding the XCM API at a technical level.

- Gavin Wood, Polkadot founder: XCM v3 | Polkadot Decoded 2022 -
  High level overview of XCM and specifically the new features available in XCM v3.

- XCMP Scheme - An
  overall overview of XCMP describing a number of design decisions.

- Messaging Overview - An overview
  of the messaging schemes from the Polkadot Parachain Host Implementor's guide.

- Sub0 Online: Getting Started with XCM - Your First Cross Chain Messages -
  Code focused workshop on how XCM v1 works, and the core concepts of XCM.

- XCM: Cross-Consensus Messaging Audit -
  Technical audit report by Quarkslab prepared for Parity.

- XCM pallet code -
  The pallet that contains XCM logic from the Polkadot code repository

- XCM Config & Pallet-XCM | Polkadot Deep Dives - A
  technical deep dive into `pallet-xcm` and the XCM configuration.

### Learn Xcm Instructions

://github.com/paritytech/xcm-format)
repository, where each instruction and register is explained in-depth.

## XCVM Registers

- _Programme_
- _Programme Counter_
- _Error_
- _Error Handler_
- _Appendix_
- _Origin_
- _Holding_
- _Surplus Weight_
- _Refunded Weight_
- _Transact Status_
- _Topic_
- _Transact Status Register_
- _Topic Register_

## XCVM Instruction Set

- `WithdrawAsset`
- `ReserveAssetDeposited`
- `ReceiveTeleportedAsset`
- `QueryResponse`
- `TransferAsset`
- `TransferReserveAsset`
- `Transact`
- `HrmpNewChannelOpenRequest`
- `HrmpChannelAccepted`
- `HrmpChannelClosing`
- `ClearOrigin`
- `DescendOrigin`
- `ReportError`
- `DepositAsset`
- `DepositReserveAsset`
- `ExchangeAsset`
- `InitiateReserveWithdraw`
- `InitiateTeleport`
- `QueryHolding`
- `BuyExecution`
- `RefundSurplus`
- `SetErrorHandler`
- `SetAppendix`
- `ClearError`
- `ClaimAsset`
- `Trap`
- `SubscribeVersion`
- `UnsubscribeVersion`
- `BurnAsset`
- `ExpectAsset`
- `ExpectError`
- `ExpectOrigin`
- `QueryPallet`
- `ExpectPallet`
- `ReportTransactStatus`
- `ClearTransactStatus`
- `LockAsset`
- `UnlockAsset`
- `NoteUnlockable`
- `RequestUnlock`

## Instructions Application Example

The following presents the practical mapping of instructions to some
core functionality in XCM.



 These are the primary instructions that enable programmability and
branching to be possible. Branching in this context is the ability for errors and logic to be
handled as needed when dealing with a message.

- `ExpectAsset(MultiAssets)` -
  Checks if the Holding register has a specific amount of assets, throws an error if it doesn't.
- `ExpectError(Option)` -
  Ensures the Error register contains the given error, and throws an error if it doesn't.
- `ExpectOrigin(MultiLocation)` -
  Ensures the Origin register contains the expected origin, and throws an error if it doesn't.
- `QueryPallet` - Queries the existence of a particular pallet type.

- `ExpectPallet` - Ensure that a particular pallet with a particular version exists.

- `ReportTransactStatus(QueryResponseInfo)` - Send a `QueryResponse` message containing the value of
  the Transact Status Register to some destination.

- `ClearTransactStatus` - Set the Transact Status Register to its default, cleared, value.





These instructions highlight the key instructions focused on Functional Multichain Decomposition.

- `LockAsset(MultiAsset, MultiLocation)` - Lock the locally held asset and prevent further transfer
  or withdrawal.

- `UnlockAsset(MultiAsset, MultiLocation)` - Remove the lock over `asset` on this chain and (if
  nothing else is preventing it) allow the asset to be transferred.

- `NoteUnlockable(MultiAsset, MultiLocation)` - Asset (`asset`) has been locked on the `origin`
  system and may not be transferred. It may only be unlocked with the receipt of the `UnlockAsset`
  instruction from this chain.

- `RequestUnlock(MultiAsset, MultiLocation)` - Send an `UnlockAsset` instruction to the `locker` for
  the given `asset`.

### Learn Xcm Transport

:

1. XCMP (Cross-Consensus Message Passing)
2. Horizontal Relay-routed Message Passing (HRMP/XCMP-lite)
3. VMP (Vertical Message Passing)

### XCMP (Cross-Chain Message Passing)

:
_Direct_ and _Relayed_.

- With _Direct_, message data goes direct between parachains and is O(1) on the side of the
  Relay-chain and is very scalable.
- With _Relayed_, message data is passed via the Relay-chain, and piggy-backs over VMP. It is much
  less scalable, and on-demand parachains in particular may not receive messages due to excessive
  queue growth.

Cross-chain transactions are resolved using a simple queuing mechanism based around a Merkle tree to
ensure fidelity. It is the task of the Relay Chain validators to move transactions on the output
queue of one parachain into the input queue of the destination parachain. However, only the
associated metadata is stored as a hash in the Relay Chain storage.

The input and output queue are sometimes referred to in the
 codebase and associated documentation
as `ingress` and `egress` messages, respectively.

://paritytech.github.io/polkadot/book/messaging.html#horizontal-message-passing).

:

- #### UMP (Upward Message Passing)

  _Upward Message Passing_ message passing from a parachain to the Relay-chain.

- #### DMP (Downward Message Passing)
  _Downward Message Passing_ message passing from the Relay-chain to a parachain.

://paritytech.github.io/polkadot/book/messaging.html#vertical-message-passing).

://www.youtube.com/watch?v=tOnzk4AROUY">



      XCMP Explained

### Learn Parachains Faq

## General

### What is "parachain consensus"?

"Parachain consensus" is special in that it will follow the
 Relay Chain. Parachains cannot use other consensus algorithms that
provide their own finality. Only sovereign chains (that must bridge to the Relay Chain via a
parachain) can control their own consensus. Parachains have control over how blocks are authored and
by whom.   guarantees valid state
transitions. Executing a block finality outside the context of the relay chain is outside the scope
of trust that   provides.

### How about parachains that are not Substrate-based?

Substrate provides FRAME Pallets
as part of its framework to seamlessly build a rustic-based blockchain. Part of FRAME are pallets
that can be used for consensus.
being a Substrate-based chain rely on BABE as the block production scheme and GRANDPA as the
finality gadget as part of its consensus mechanism. Collectively, this is a
Hybrid Consensus Model, where block production and block
finality are separate. Parachains only need to produce blocks as they can rely on the relay chain to
validate the state transitions. Thus, parachains can have their own block production where the
collators act as the block producers, even if the parachain is not
Substrate-based.

### Is 100 a hard limit on the number of Parachains that can be supported?

No.  network went through a
significant number of optimizations, and there are
several updates planned in the near
future. The exact number of parachains that the Relay Chain can support without any degradation in
performance is yet to be discovered. Also, with the
blockspace over blockchains paradigm
which brings on-demand parachains into the picture, there is no hard limit number on the number of
blockchains that can be supported by
.

### What happens to parachains when the number of validators drops below a certain threshold?

The minimal safe ratio of validators per parachain is 5:1. With a sufficiently large set of
validators, the randomness of their distribution along with
availability and validity will make sure security is
on-par. However, should there be a big outage of a popular cloud provider or another network
connectivity catastrophe, it is reasonable to expect that the number of validators per chain will
drop.

Depending on how many validators went offline, the outcome differs.

If a few validators went offline, the parachains whose validator groups are too small to validate a
block will skip those blocks. Their block production speed will slow down to an increment of six
seconds until the situation is resolved and the optimal number of validators is in that parachain's
validator group again.

If anywhere from 30% to 50% of the validators go offline, availability will suffer because we need
two-thirds of the validator set to back the parachain candidates. In other words, all parachains
will stop until the situation is resolved. Finality will also stop, but low-value transactions on
the Relay Chain should be safe enough to execute, despite common forks. Once the required number of
validators are in the validator set again, parachains will resume block production.

Given that collators are full nodes of the Relay Chain and the parachain they are running, they will
be able to recognize a disruption as soon as it occurs and should stop producing block candidates.
Likewise, it should be easy for them to recognize when it's safe to restart block production -
perhaps based on finality delay, validator set size or some other factor that is yet to be decided
within Cumulus.

### Parachain Development Kits (PDKs)

Parachain Development Kits are a set of tools that enable developers to create their own
applications as parachains. For more information, see the PDK
content](../build/build-parachains.md#parachain-development-kit-pdk) and
Parachain Development page.

## Security

### Is security correlated to the number of validators? What about the number of parachains?

Security is independent of the number of parachains that are connected to the Polkadot Relay Chain.
The correlation of security and the number of validators exists as the higher number of validators
will give the network stronger decentralization properties and make it harder to try to take down.
However, the biggest indicator of the security of the network is the economic signal of the number
of DOT that are bonded and staked. The greater the number of DOT staked by honest validators and
nominators, the higher the minimum amount of DOT an attacker would need to acquire a validator slot.

### In what scenarios do parachains need their own security?

Most parachains will not need to worry about their own security, since all state transitions will be
secured by the Polkadot Relay Chain validator set. However, in some cases (which are considered more
experimental), parachains may require their own security. In general, these cases will revolve
around lack of data available to Relay Chain validators.

One example is if the state transition function is some succinct or zero-knowledge proof, the
parachain would be responsible for keeping its data available as the Relay Chain won't have it.
Additionally, for chains with their own consensus, like the one that enables fast payments on
Blink Network, there would probably need to be a
Byzantine agreement between stakers before a parachain block is valid. The agreement would be
necessary because the data associated with the fast consensus would be unknown to Relay Chain
validators.

## Slot Auctions

### How will parachain slots be distributed?

Parachain slots are acquirable through auction. For more information on the auction process, please
see the parachain slot auctions article. Additionally, parachains will be able
to access the Relay Chain on-demand.

### Why doesn't everyone bid for the max length?

For the duration of the slot, the tokens used for bidding in the auction are locked up. This
suggests there is an opportunity cost associated with bidding, as the tokens could have been
leveraged for something else.

### How does this mechanism help ensure parachain diversity?

The method for dividing the parachain slots into intervals was partly inspired by the desire to
allow for a greater amount of parachain diversity, while preventing particularly large and
well-funded parachains from hoarding slots. By making each period a
{{ polkadot: three-month duration but the
overall slot a 2-year duration :polkadot }}{{ kusama: 6-week duration but the overall slot a 1-year
duration :kusama }}, the mechanism can cope with well-funded parachains, ensuring they secure a slot
at the end of their lease, while gradually allowing other parachains to enter the ecosystem to
occupy the durations that are not filled. For example, if a large, well-funded parachain has already
acquired a slot for range 1 - 8, they would be very interested in getting the next slot that would
open for 2 - 9. Under this mechanism, that parachain could acquire just period 9 (since that is the
only one required) and allow the 2 - 8 range of the second parachain slot to be occupied by another
party.

### Why is randomness difficult on blockchains?

Generating a random number trustlessly on a transparent and open network opens up the possibility
for bad actors to attempt to alter or manipulate the randomness. There have been a few solutions
that have been proposed, including hash-onions like RANDAO and
verifiable random functions (VRFs). The
latter is what  uses as a base for its
randomness.

### Are there other ways of acquiring a slot besides the candle auction?

Aa parachain slot can also be acquired through a secondary market where a 3rd party has already won
a parachain slot and has the ability to resell the slot along with the associated deposit of tokens
that are locked up to another buyer. This would allow the seller to get liquid tokens in exchange
for the parachain slot and the buyer to acquire the slot as well as the deposited tokens.

A number of system or common-good parachains may be granted slots by the
governance of the Relay Chain. System parachains can be recognized by
a parachain ID lower than 1_000, and common-good parachains by a parachain ID between 1_000 and
1_999. Other parachains will have IDs 2_000 or higher. Such parachains would not have to bid for or
renew their slots as they would be considered essential to the ecosystem's future.

### How are auctions scheduled?

The parachain slot auctions are scheduled through the governance. At least 2/3 of the Council can
initiate an auction, however, Root origin (via referendum) is needed to cancel an auction. Here is a
proposal that gives a glimpse of what goes into planning auctions schedule -
Proposed Polkadot Auction Schedule 2022.

### Learn Parachains Protocol

://paritytech.github.io/polkadot/book/protocol-overview.html)
and the
Availability and Validity (AnV) chapter in **The Polkadot Protocol Specification**.

: Deprecated

Fishermen are not available on  and
are not planned for formal implementation, despite previous proposals in the
AnV protocol.

The idea behind Fishermen is that they are full nodes of parachains, like collators, but perform a
different role in relation to the
network. Instead of packaging the state transitions and producing the next parachain blocks as
collators do, fishermen will watch this process and ensure no invalid state transitions are
included.

To address the motivation behind the Fishermen design consideration, the current
secondary backing checkers perform a similar role in relation to
the  network. From a security
standpoint, security is based on having at least one honest validator either among parachain
validators or secondary checker (more about this later on).

## Protocols' Summary

### Parachain Protocol

The parachain protocol is divided into two main phases:

- **Inclusion Pipeline**: Collators send parachain blocks (parablocks) with
  PoV to Validators. Validators verify if the parablocks follow the state transition rules of the
  parachain and sign statements that can have a positive or negative outcome. With enough positive
  statements, the block is **backed** and **included** in the Relay Chain, but is still pending
  approval.
- **Approval Process**: Validators perform additional checks that, if positive,
  allow the parablock to be **approved**.

The figure below shows a representation of a parachain with collators and validators. The figure
also shows the journey of a parachain block (white square) through the Inclusion Pipeline and the
Approval Process.

!parachain-protocol-summary

### Availability and Validity (AnV) Protocol

The Availability and Validity (AnV) Protocol is a way of looking at the Parachain Protocol from
another perspective, emphasizing the importance of a parablock being available and valid before
being included in the finalized Relay Chain. It is divided into five different phases, three within
the Inclusion Pipeline and two within the
Approval Process:

- **Inclusion Pipeline**
  1.  Parachain phase
  2.  Relay Chain submission phase
  3.  Availability and unavailability phase
- **Approval Process**
  1.  Assignments and secondary (validity) checks
  2.  Chain Selection

In the Inclusion Pipeline, a parablock is made available (or unavailable), while in the Approval
Process a parablock is checked if it is valid or not.

## Inclusion Pipeline

### Overview

The inclusion pipeline is the path of a parachain block (or parablock) from its creation to its
inclusion into the non-finalized Relay Chain (i.e. in a fork of the Relay Chain).

!parachain-inclusion-pipeline

The figure above shows the path of a candidate block through the Inclusion pipeline. The block
changes its status through this path as follows:

- Candidate: A block with its PoV is put forward by a collator to a para-validator (in this case
  V1). The candidate block is shown as a white square with one white tick mark at the side (PoV from
  the collator). Note the candidate is not valid yet and can still fail to be included in the Relay
  Chain.
- Seconded: The block is put forward by the para-validator V1 to other para-validators (in this case
  V2 and V3). The seconded block is shown as a white square with a white tick mark and a yellow tick
  mark on top of it. The yellow mark show the PoV from para-validator V1.
- Backable: The block validity is attested by a majority of the para-validators. The backable block
  is shown as white square with a white tick mark and three yellow tick marks on top of it. The
  yellow marks show the PoV from the para-validators, while the white mark the PoV from the
  collator.
- Backed: The block is backed and noted in a fork on the Relay Chain by a relay chain block author
  (in this case V4). The backed block is shown as a square with white background and yellow border
  enclosing a "B". The backed block can still fail to be included in the Relay Chain. Note that for
  simplicity here the backed parachain block is represented within the Relay Chain block, but in
  reality a relay chain block does not contain the parablocks themselves (more about this later).
- Pending availability: The block is backed but not considered available yet.
- Included: The block is backed and considered available (we have a parablock). Included parablocks
  are shown as square with white background and yellow border enclosing an "I".

:

- The block candidate (list of state transitions)
- The values in the parachain's database that the block modifies
- The hashes of the unaffected points in the Merkle tree

This set of information is the proof-of-validity (PoV).

Once a para-validator has the PoV, it gossips this information to the other para-validators, who
check the candidate block against the PoV. Candidates that gather more than half of signed validity
statements are considered **backable** (i.e. they _seem_ to represent a valid state transition), and
their backing is the set of signed statements. The para-validators can then start to construct the
**candidate receipt** (this is what goes into the Relay Chain block) and an
**erasure coding** (this is what will make the parablock available, more on this
later on) that will be sent to all validators in the network.

:

- The collator cannot propagate the block to any of the assigned validators.
- The candidate is not backed by validators participating in the Candidate Backing subsystem.
- A relay chain block author does not select the candidate.
- The candidate's PoV is not considered available within a timeout, and the block is discarded from
  the Relay Chain.

## Approval Process

### Overview

Once the parablock is considered available and part of the parachain, it is still "pending
approval". At this stage, the parablock is tentatively included in the parachain, although more
confirmation is necessary. The validators assigned to the parachain (i.e. the parachain validators)
are sampled from a validator set assumed to be 1/3 dishonest in the worst-case scenario. In this
case, it is likely that the majority of the random para-validators sampled for a specific parachain
are dishonest and can back a candidate wrongly. To address this, the **Approval Process** allows
detecting misbehavior after the fact without allocating more para-validators, which would ultimately
reduce the system's throughput. As a parablock can accept children blocks after being considered
available, failure to pass the approval process will invalidate the parablock and its descendants
(children blocks). Only the validators who backed the block in question will be slashed, not those
who backed the descendants.

The approval pipeline can be divided into the following steps:

1. Parablocks included by the Inclusion Pipeline are pending approval for a time window known as the
   **secondary checking window**.
2. During the secondary checking window, validators (secondary checkers) randomly self-select based
   on a VRF lottery to perform secondary checks on each of the
   parablock.
3. Secondary checkers acquire the parablock with PoV (erasure codings are necessary to reconstruct
   PoV) and re-run the validation function.
4. Secondary checkers gossip about the results of their checks. Contradictory results lead to an
   escalation in which all validators must check the block. The validators on the losing side will
   be slashed.
5. At the end of the process the parablock is either approved or rejected.

The figure below shows the path of a parachain block when it exits the Inclusion Pipeline, and
enters the Approval Process. The parablock becomes accepted when it is backed, available and
**undisputed**. The parablock is checked a second time by a subset of validators (V5, V6 and V7),
and if there are no contradictory results the block is approved and gossiped to other relay chain
validators. Note the parablock after secondary checks is shown as a square with a white background a
yellow border enclosing an "I" (stands for _included_), and three white ticks (one for each
secondary check). Approved para-blocks are shown as yellow squares.

!parachain-approval-process

### Assignments & Secondary Checks

Having a bad parablock on a fork of the relay chain is not catastrophic as long as the block is not
approved and finalized by the finality gadget
GRANDPA. If the block is not finalized, the fork on
the chain containing that block can be ignored in favor of another fork containing good blocks.
Dealing with a bad parablock includes the following stages:

- Detection: the bad block must be detected by honest validators.
- Escalation: the honest validators must start a dispute.
- Consequences: all involved malicious validators are slashed.

The result of the dispute must be transplantable to all other forks so that malicious validators are
slashed in all possible histories and so that honest validators will ignore any forks containing
that parablock.

:

- **Assignments**
  determine which validators perform approval checks on which candidates, ensuring each candidate
  receives enough random checkers. This stage tracks approval votes to identify when
  no-show approval
  checks take suspiciously long. It also tracks relay chain
  equivocations to
  determine when adversaries possibly gained foreknowledge about assignments and add more checks in
  those cases. Assignees determine their own assignments to check specific candidates using two or
  three
  assignment criteria,
  which are based on two possible
  stories about the
  relay chain block that included the candidate (i.e. declared the candidate available).
  Assignment notices
  are gossiped among nodes so that all validators know which validators should check which
  candidates, and if any candidate requires more checkers.
- **Approval checks** perform the checks by obtaining the candidate, verifying its validity, sending
  out the approval vote, or initiating a dispute. Approval checks have a no-show timeout window
  (i.e. longer than one relay chain slot) to succeed in reconstructing the candidate block, redo its
  erasure coding to check the candidate receipt, and recheck the candidate block itself. A validator
  becomes tagged as a no-show if it does not approve or dispute within the no-show timeout window.
  Because validators can be overloaded with assignments, they can intentionally delay sending their
  assignment notice to avoid creating no-shows (see more in
  Assignment postponement).

These two steps first run as off-chain consensus protocols using messages gossiped among all
validators, and then as on-chain record of those protocols' progress. The on-chain protocol is
needed to provide rewards for the off-chain protocol. The
on-chain verification
has two phases: a) assignments notices and approval votes are recorded in a relay chain block, and
b) in another relay chain block notes are fed into the approval code.

The gossiped messages are of two types, assignment notices, and approval votes, and are signed with
approval keys.
Such keys are part of the session keys used by validators.
Briefly, approval keys are:

- **Approval assignment keys** that are sr25519 keys used only for assignment criteria
  VRF.
- **Approval vote keys** that are ed25519 and would only sign off on a candidate parablock validity.

://paritytech.github.io/polkadot/book/protocol-approval.html).

://paritytech.github.io/polkadot/book/protocol-chain-selection.html)_
and a set of
_finality constraints_.

://paritytech.github.io/polkadot/book/protocol-chain-selection.html).

: candidate receipts. A
para-validator constructs a candidate receipt for a parachain block by signing:

- The parachain ID.
- The collator's ID and signature.
- A hash of the parent block's candidate receipt.
- A Merkle root of the block's erasure-coded pieces.
- A Merkle root of any outgoing messages.
- A hash of the block.
- The state root of the parachain before block execution.
- The state root of the parachain after block execution.

This information is of constant size, while the actual PoV block of the parachain can be variable
length. It is enough information for anyone that obtains the full PoV block to verify the state
transition contained inside of it.

## Erasure Codes

Before sending the candidate receipt to the Relay Chain transaction queue, the para-validator who
constructs the receipt must also construct an erasure coding of the parachain block.

An erasure coding takes a message (in this case, the parachain block and PoV) and creates a set of
smaller messages such that you can reconstruct the original message by obtaining a fraction of the
smaller messages. In the case of  the
total number of smaller messages is equal to the total number of validators and the fraction is 1/3.

The para-validator creates the erasure coding chunks, puts them into their Merkle tree, and sends
out each chunk (together with the candidate receipt) to a corresponding validator on the Relay
Chain. Validators who receive the receipts with an erasure coding chunk will include the receipt in
the Relay Chain queue, where an author can include it in a block.

The type of erasure codes used by 's
availability scheme are
Reed-Solomon codes, which
already enjoy a battle-tested application in technology outside the blockchain industry. One example
is found in the compact disk industry. CDs use Reed-Solomon codes to correct any missing data due to
inconsistencies on the disk face such as dust particles or scratches.

In , the erasure codes are used to
keep parachain state available to the system without requiring all validators to keep tabs on all
the parachains. Instead, validators share smaller pieces of the data and can later reconstruct the
entire data under the assumption that 1/3+1 of the validators can provide their pieces of the data.

:

- A parablock included on a branch of the relay chain is bad
- A parablock backed on a branch of the relay chain is bad
- A parablock seconded, but not backed on any branch of the relay chain, is bad

Checking a parachain block requires three pieces of data: the parachain validator code, the
availability of data, and the candidate receipt. The validator code is available on-chain and
published ahead of time. Thus, a dispute process begins with the availability to ensure the
availability of the data. Such a process will conclude quickly if the data is already available,
otherwise, the initiator of the dispute must make it available.

Disputes have both off- and on-chain components. Slashing is handled on-chain, so votes by
validators on either side of the dispute must be placed on-chain. Moreover, a dispute on one branch
of the chain must be transposed to all active branches so that misbehavior can be punished in all
possible histories. There is, thus, a distinction between _local_ (the one we are looking at) and
_remote_ disputes relative to a particular branch of the relay chain.

Disputes can be divided into three different phases:

- Dispute initiation:
  Disputes are initiated by any validator who finds their opinion on the validity of a parablock in
  opposition to another issued statement. The initiation begins off-chain by only nodes perceiving
  that a parablock is bad. The validator can be one of the para-validators (i.e. one of the backers)
  or one of the approval checkers. Note that if the dispute occurs during the backing phase, the
  initiator must make the data available while if the dispute occurs during the approval process the
  data is already available.
- Dispute participation:
  Once becoming aware of the dispute, all validators must participate.
- Dispute conclusion:
  Disputes conclude after a 2/3 supermajority is reached on either side. Disputes may also conclude
  after a timeout. This will only happen if the majority of validators are unable to vote for some
  reason.

The on-chain component of the dispute can be initiated by providing any two conflicting votes and it
also waits for a 2/3 supermajority on either side. The component also tracks which parablocks have
already been disputed so that the same parablock can be disputed only once on any branch of the
relay chain. Inclusion is halted for the parachain until the dispute resolves.

://paritytech.github.io/polkadot/book/protocol-disputes.html).
In the Guide, there are also more details about
disputes' flows.

://polkadot.network/the-path-of-a-parachain-block/) - Article by
  Parity analyst Joe Petrowski expounds on the validity checks that a parachain block must pass in
  order to progress the parachain.
- Availability and Validity -
  Paper by the W3F Research Team that specifies the availability and validity protocol in detail.

### Learn Parachains

://polkadot.network/blog/the-path-of-a-parachain-block/) a
good analogy of a state with a light switch that can be either on or off, which is one of the
simplest examples of how a state machine functions. Each parachain has its own state, and the Relay
Chain links all those states into one state, i.e. a state of states. A multi-chain network like
 can be viewed like one computer's
state with many light switches where a **state transition function** is the logic to decide which
switches should be toggled. Parachains have their own transition rule, separate economies,
governance mechanisms, and users.

A parachain's state is stored in a Merkle tree. Merkle
trees have the convenient property that if some values within the tree change, this will be
reflected in the Merkle root (in this case, the state root). One can verify the change by only
looking at the new values and the paths that are affected within the tree.

The  Host requires that the state
transitions performed on parachains be specified as a Wasm executable. Proofs of
new state transitions that occur on a parachain must be validated against the registered state
transition function (STF) that is stored on the Relay Chain by the validators before
 acknowledges a state transition has
occurred on a parachain. The key constraint regarding the logic of a parachain is that it must be
verifiable by the Relay Chain validators. Verification most commonly takes the form of a bundled
proof of a state transition known as a Proof-of-Verification (PoV) block, which is submitted for
checking to the validators from one or more parachain collators.

## Why Parachains?

Parachains are a solution to two fundamental problems in blockchains:

- **Scalability**: Having one blockchain for many purposes makes it difficult to scale as future
  implementations and upgrades will likely advantage some purposes and disadvantage others.
  Conversely, having different blockchains will allow them to implement features without affecting
  other chains.
- **Flexibility**: It is reasonable to state a blockchain will either be really good at solving one
  problem or not so good at trying to solve many problems. A blockchain specializing in solving a
  specific problem has more leverage toward itself and its users. Parachains are purpose-built
  blockchains are highly specialized and can take advantage of each other through cooperation.

### Parachain Benefits

Parachains contain their own runtime/STF logic and benefit from the shared security and the
cross-consensus messaging provided by the  relay chain. Parachains
permit high flexibility and customization but require more effort to create and maintain over time.
A production-grade parachain is typically more involved to create due to the complexity involved in
blockchain networks' technical and economic aspects.

Parachains grant the creators more space to build the monetary system and other chain aspects from
the ground up. They will allow for a more concise and efficient execution of complex logic than a
smart contract platform could offer. Parachains also provide more flexibility in the form of
governance and can perform complete upgrades in a less controversial way than the current process of
hard forks.

Some examples of features you can have on a parachain or parathread:

- Custom fee structure (for example, pay a flat transaction fee or pay per byte).
- Shared security and finalization via the relay chain (Polkadot or Kusama).
- Custom monetary policy for the native token and local economy.
- Treasury to be funded through transitions in your state function.
- A governance mechanism that could manage a DAO that is responsible for allocating your on-chain
  treasury.

### Shared Security

Shared security, sometimes referred as _pooled security_, is one of the unique value propositions
for chains considering becoming a parachain and joining the
 network. On a high level, shared
security means that all parachains that are connected to the
 Relay Chain by leasing a parachain
slot will benefit from the economic security provided by the Relay Chain
validators.

The notion of shared security is different from inter-chain protocols that build on an architecture
of bridges. For bridge protocols, each chain is considered sovereign and must maintain its own
validator set and economic security. One concern in these protocols is the point of scalability of
security. For example, one suggestion to scale blockchains is that of _scale by altcoins,_ which
suggests that transaction volumes will filter down to lower market cap altcoins as the bigger ones
fill their blocks. A major flaw in this idea is that the lower market cap coins will have less
economic security attached and be easier to attack. A real-life example of a 51% attack occurred
recently (
Ethereum Classic attack on January 10, 2019
), in which an unknown attacker double spent 219_500 ETC (~1.1 million USD). This was followed by
two more 51% attacks on ETC.

 overcomes security scalability
concerns since it gravitates all the economic incentives to the Relay Chain and allows the
parachains to tap into stronger guarantees at genesis. Sovereign chains must expend much more effort
to grow the value of their coin so that it is sufficiently secure against well-funded attackers.

### PoW vs Parachain Model

Let's compare the standard sovereign security model that exists on current proof-of-work (PoW)
chains to that of the shared security of
 Chains secured by their security
models, like Bitcoin, Zcash, and their derivatives, must bootstrap their independent network of
miners and maintain a competitive portion of honest hashing power. Since mining is becoming a larger
industry that increasingly centralizes key players, it is becoming more real that a single actor may
control enough hash power to attack a chain.

This means that smaller chains that cannot maintain a secure amount of hash power on their networks
could potentially be attacked by a large mining cartel at the simple whim of redirecting its hash
power away from Bitcoin and toward a new and less secure chain.
51% attacks are viable today with attacks having been reported on
Ethereum Classic (see above),
Verge,
Bitcoin Gold, and other cryptocurrencies.

On , this disparity between chain
security will not be present. When a parachain connects to
, the relay chain validators become
the securers of that parachain's state transitions. The parachain will only have the overhead of
running a few collator nodes to keep the validators informed with the latest state transitions and
proofs/witness. Validators will then check these for the parachains to which they are assigned. In
this way, new parachains instantly benefit from the overall security of
 even if they have just been launched.

## Parachain Economies

Parachains may have their economies with their native tokens. Schemes such as Proof-of-Stake are
usually used to select the validator set to handle validation and finalization; parachains will not
be required to do either of those things. However, since
 is not overly particular about what
the parachain can implement, it may be the choice of the parachain to implement a staking token, but
it's not generally necessary.

Collators may be incentivized through the inflation of a native parachain token. There may be other
ways to incentivize the collator nodes that do not involve inflating the native parachain token.

Transaction fees in a native parachain token can also be an implementation choice of parachains.
 makes no hard and fast rules for how
the parachains decide on the original validity of transactions. For example, a parachain may be
implemented so that transactions must pay a minimum fee to collators to be valid. The Relay Chain
will enforce this validity. Similarly, a parachain could not include that in their implementation,
and  would still enforce its validity.

Parachains are not required to have their token. If they do, it is up to the parachain to make the
economic case for their token, not .

## Parachain Slot Acquisition

There are two ways to allocate parachain slots on
:

- Governance granted parachains, or "system parachains"
- Auction granted parachains

System parachains are allocated by
's on-chain
governance and are part of the network's protocol, such as bridges to
other networks or chains. These typically do not have an economic model and help remove transactions
from the Relay Chain, allowing for more efficient parachain processing.

Auction granted parachains are granted in a permissionless auction. Parachain
teams can either bid with their own  tokens,
or source them from the community using the crowdloan functionality.

### Parachain Lease Expiration

When a parachain wins an auction, the tokens it bids get reserved until the lease's end. Reserved
balances are non-transferrable and cannot be used for staking. At the end of the lease, the tokens
are unreserved. Parachains without a new lease to extend their slot will be deprecated to the status
of a parathread (i.e., a chain with a registered `ParaID` but has no access to a core).

## System Parachains

System parachains are parachains that use execution cores allocated by
the network's governance. These chains remove transactions from the Relay Chain, allowing network
validators to allocate resources to validating parachains. System chains are Polkadot using its
scaling technology to host itself.

See this
Polkadot blog article
and this
Polkadot Forum thread
for more information.

## On-demand Parachains

://v.douyu.com/show/a4Jj7llO5q47Dk01) in Chengdu back in 2019, the
origin of the idea for on-demand parachains came from similar notions in the limited resource of
memory on early personal computers of the late '80s and '90s. Since computers have a limited amount
of physical memory, when an application needs more, the computer can create virtual memory by using
_swap space_ on a hard disk. Swap space allows the capacity of a computer's memory to expand and for
more processes to run concurrently with the trade-off that some processes will take longer to
progress.

### Parachains vs. On-demand Parachains

Parachains and on-demand parachains are very similar from a development perspective. One can imagine
that a chain developed with Substrate can at different points in its lifetime assume one of three
states:

- an independent chain with secured bridge,
- a parachain continuously connected to the Relay Chain,
- or a parachain intermittently connected to the Relay Chain (i.e. on-demand)

It can switch between these states with relatively minimal effort since the difference is more of an
economic distinction than a technological one.

On-demand parachains have the exact same benefits for connecting to
  that a full parachain has. Namely,
it is able to send messages to other para-objects through XCMP and it is
secured under the full economic security of
's validator set.

## Parachains' Use Cases

Note that we still have to see the true potential of parachains and what it is listed below are just
a few examples.

- **Encrypted Consortium Chains**: These are possibly private chains that do not leak any
  information to the public but still can be interacted with trustlessly due to the nature of the
  XCMP protocol.
- **High-Frequency Chains**: These chains can compute many transactions in a short amount of time by
  taking certain trade-offs or making optimizations.
- **Privacy Chains**: These chains do not leak any information to the public through novel
  cryptography.
- **Smart Contract Chains**: These chains can have additional logic implemented through the
  deployment of code known as _smart contracts_.

## Parachain Host

 includes a blockchain called a relay
chain. A blockchain is a
Directed Acyclic Graph (DAG) of state
transitions, where every added block can be viewed as the head of the chain or fork with cumulative
state. All paths through the DAG terminate at the Genesis Block. A blockchain is a tree, as each
block can have only one parent.

A blockchain network is made of nodes that have a view of many forks of the chain and must decide
which fork to follow. To construct the parachain host we need to answer two categories of questions
addressed by two different components:

- What is the state transition function of the blockchain? This is handled by the **Runtime**, which
  defines the state transition logic of the chain. The Runtime logic is divided into:

  - **Modules** encapsulate particular behavior of the protocol and consist of:
    - Storage
    - Routines are invoked by entry points and other modules upon block initialization or closing.
      Routines can alter the storage of a module.
    - The entry point defines how new information is introduced to a module and can limit the origin
      from which they are called (user, root, parachain).
  - **API** provides means for the node-side behavior to extract meaningful information from the
    state of a single fork.

  ://paritytech.github.io/polkadot/book/runtime/index.html) and
  Runtime API.

  :

  - **Networking behaviors**, relate to how information is distributed between nodes but not how the
    information is used afterward.
  - **Core behaviors**, relate to internal work that a specific node does. Such behavior cares about
    that information is _distributed_ and _received_, but not how these two are achieved.

  These two categories often interact, but they can be heavily abstracted from each other. The
  node-side behavior is split into various **subsystems**, which perform a particular category of
  work. Subsystems can communicate with each other through an
  Overseer that prevents race
  conditions.

  ://paritytech.github.io/polkadot/book/node/index.html) the main
  subsystems:

  - Collator subsystem
  - Backing subsystem
  - Availability subsystem
  - Approval subsystem
  - Dispute subsystem
  - Utility subsystem

  : The Parachain](https://medium.com/polkadot-network/polkadot-the-parachain-3808040a769a) -
  Blog post by Polkadot co-founder Rob Habermeier who introduced parachains in 2017 as "a simpler
  form of blockchain, which attaches to the security provided by a Relay Chain rather than providing
  its own. The Relay Chain provides security to attached parachains, but also provides a guarantee
  of secure message-passing between them."
- The Path of a Parachain Block - A
  technical walk-through of how parachains interact with the Relay Chain.

### Learn Guides Coretime Parachains

:

- **Migrating** from a legacy parachain lease into a
  bulk coretime model
- **Starting** with bulk coretime model from scratch
- **Running** a parachain with on-demand coretime purchases ("pay as you go")

The parachain lease auctions will stop on-chain with the enactment of the
runtime upgrade 1.2.0, and the
existing leases will be migrated to bulk coretime automatically. Leases that are yet to be started
will be canceled and the locked
will be refunded. The existing parachains benefit from
coretime renewals which allows for the continued
assignment of bulk coretime for a core without going through the regular purchasing process.

://github.com/paritytech/polkadot-sdk/tree/6f3d890ed35bfdee3e3f7d59018345635a62d1cd/polkadot/parachain/test-parachains/adder)
on the Polkadot SDK has been used. To compile the `adder-collator`, run the command below in the
_root_ of the Polkadot SDK repository. You must have Rust
and its associated tooling installed before following along.

Ensure the Polkadot SDK is cloned, and you are within the root directory (`cd polkadot-sdk`)

```sh
cargo build -r -p test-parachain-adder-collator
```

After the test parachain collator node is successfully compiled, export its genesis state and the
code using the following commands. If the export succeeds, these two files should appear in the
Polkadot-SDK repository.

```sh
./target/release/adder-collator export-genesis-state genesis
```

```sh
./target/release/adder-collator export-genesis-wasm genesis-wasm
```

## Reserve ParaID

:


-  on Kusama


-  on Polkadot

://polkadot.js.org/apps/#/parachains/parathreads) and
clicking on ParaID button. Ensure that you have sufficient tokens to reserve the displayed `ParaID`
successfully.

!coretime-reserve-paraID

## Register Parachain State and Code

The next step is to register the parachain's genesis wasm and state, which you should have generated
earlier. Note that for this example, we are using `adder-collator`, but in theory a custom runtime
compiled from a
template
would work as well.


:


- **Kusama**:  per byte


- **Polkadot**:  per byte

The deposit used for registering `ParaID` is already counted in for this deposit, the total deposit
requirement for registering `ParaID`, state and code for `adder-collator` is around 46 KSM on Kusama
and 116 DOT on Polkadot.

: **bulk coretime** and **on-demand coretime**. Bulk coretime is
purchased via the `broker` pallet, which is on the respective Coretime system parachain. On-demand
coretime is ordered via the `OnDemandAssignment` pallet/module, which is located on the respective
relay chain.

://test.lastic.xyz/) interface.

!coretime-bulk-assign-lastic

After successful assignment of the core, the `adder-collator` logs show new collations at regular
intervals, gradually incrementing the state by `2`.

!coretime-collation-bulk

## Run a Parachain with On-demand Coretime

After the collator node is fully synced with the relay chain, navigate to
Developer > Extrinsics on the relay chain and issue
`onDemandAssignmentProvider.placeOrderAllowDeath` extrinsic from the account that registered the
`ParaID` by specifying sufficient `maxAmount`for the transaction to go through successfully.

!coretime-ondemand-assignment

:

- `onDemandAssignmentProvider.placeOrderAllowDeath` will
  reap the account once the provided funds
  run out.

- `onDemandAssignmentProvider.placeOrderKeepAlive` includes a check which will **not** reap the
  account if the provided funds will run out, ensuring the account is kept alive.

### Parachains Apps

://polkadot.network/ecosystem/dapps/). This page also features
a form that can be submitted to showcase dApps that are not already listed.

://polkadot.network/ecosystem/dapps/) and then use this page to
elaborate their key features to the Pokadot Wiki readers. This page is open to contributions from
the community. Please follow the
Wiki contribution guidelines
and add your parachain app to this page.

://astar.network/) is an interoperable smart contracts platform for Polkadot and
Ethereum ecosystems supporting both Wasm and EVM smart contracts. Astar provides native access to
Polkadot and Ethereum through its parachain slot and Layer 2 scaling solution, while also offering
bridges into other major blockchain ecosystems.

Through the dApp staking, Astar offers a
basic income to dApp developers, which allows them to continue building and enhancing their dApps
without a pressing need to apply for grant programs, issue tokens and fundraise to earn money. At
every block, a portion of the rewards goes to dApp staking and is then divided between operators
(developers) and nominators. As a dApp grows in popularity, more members of the community nominate
the dApp, and this, in turn, enables the developers who built the dApp to receive a greater
percentage of the block reward.

### Astar Portal

Astar Portal is a one-stop-place for interaction with Astar
ecosystem, and an exclusive platform for Astar
dApp staking — users can
nominate their
Astar/Shiden tokens on specific dApps they wish to support and get a portion of the rewards
distributed at every block. Portal also allows unbonding, rewards compounding and nomination
transfer.

![](https://portal.astar.network/)

Astar Portal supports Polkadot native accounts (Polkadot.js, Talisman, SubWallet, Clover, Math
Wallet, Hana Wallet, OneKey), Multisig accounts (PolkaSafe) and EVM accounts (MetaMask, Talisman,
SubWallet, Hana Wallet, OneKey).

![](https://portal.astar.network/)

### Astar dApps

Astar Network allows developers to use and build smart contracts in ways they never have before,
leading to the realization of truly innovative solutions that can't be replicated in any other
environment.

- ArthSwap

ArthSwap is a one-stop DeFi protocol that aspires to be the main DEX on the Astar Network. The
primary products are trading, staking, IDO launchpad, and liquidity farming, with other capabilities
to be consistently added.

- Algem

Algem is a native liquid staking DeFi dApp on top of Astar Network, offering new ways for ASTR users
and holders to earn more. It empowers users to increase their earnings potential by staking while
yield farming.

- AstridDao

AstridDAO aims to be the leading decentralized money market protocol and the dominant stablecoin,
$BAI, in the Astar/Polkadot ecosystem. AstridDAO is a decentralized borrowing protocol that allows
users to draw interest-free loans against multiple collateral assets (e.g., ASTR, ETH, BTC).

- Starlay Finance

Starlay Finance is a protocol for users to quickly and easily deposit and borrow assets on Astar
Network. In other words, users can do “Low Risk Farming on Astar Network”. Depositors can provide
liquidity to earn interest as a stable passive income, while borrowers can leverage their assets
without selling them out.

- Zenlink

Zenlink is an underlying cross-chain DEX protocol. By accessing the ultimate, open and universal
cross-chain DEX protocol based on Substrate, Zenlink DEX Protocol enables all parachains to build
DEX and achieve liquidity sharing in one click.

- XY Finance

XY Finance is a cross-chain interoperability protocol aggregating DEXs & Bridges. Based on the data
from DeFi Llama, XY Finance is the top bridge protocol on Astar, opening gateways to users who have
yet to experience Astar’s ecosystem.

- SiO2 Finance

SiO2 Finance is the Multi-VM Lending Hub on Astar for Polkadot, that supports both EVM and WASM.
SiO2 Finance is the built of the community, by the community, for the community.

- tofuNFT

tofuNFT is a permissionless, decentralized and full-featured NFT marketplace, providing numerous
creative improvements to the existing marketplace experience like incentivized bidding, real-time
notification, attributes filtering, bulk listing, and rarity explorer.

- Bluez NFT Marketplace

Bluez is a distinctive NFT marketplace that empowers users to create, purchase, and sell NFTs with
the power of XVM (Cross Virtual Machine). This community-driven platform offers a versatile and
adaptable approach to NFT trading, enabling users to harness the benefits of both EVM and WASM for
greater flexibility and convenience.

- Cosmize

In Cosmize everybody can create and customize their own cosmic imagination. This platform allows for
creating community activities, events, quests, and more. It is a place for making imagination become
reality, to embrace the spirit of decentralization through community-driven activities.

- HEALTHREE

HEALTHREE platform allows users to earn unique tokens ($UHT: Utility Health Token / $GHT: Governance
Health Token) by engaging in ongoing healthy activities, especially diet, exercise, and sleep. In
addition, users can earn additional tokens and rewards through gamification.

Discover more Astar dApps on
Astar Portal.

## Bifrost Finance

Bifrost is a dedicated liquid staking middle layer built on Substrate,
powered by Polkadot, providing non-custodial decentralized cross-chain liquid tokens for staked
assets. By leveraging Polkadot’s cross-consensus message format (XCM), Bifrost provides standardized
cross-chain liquid staking solutions for multiple chains currently Polkadot (vDOT), Kusama (vKSM),
Moonbeam (vGLMR), Moonriver (vMOVR) and other chains notably vASTR (Astar) and vFIL (Filecoin).

Through Bifrost Staking Liquidity Protocol
(SLP),
Bifost facilitates the issuance and deployment of liquid staked assets (“vTokens' '), allowing users
to earn staking rewards while retaining their governance rights and participating in DeFi, such as
liquidity provisioning on DEXs, providing collateral on lending/borrowing protocols and for
stablecoin issuance as well as restaking for securing decentralized solutions. Bifrost vTokens are
reward-bearing liquid staking tokens representing the users staked asset, including returns from
staking. As staking rewards are received, vTokens increase in value without changing the quantity of
tokens.

Bifrost aims to offer seamless staking and DeFi experience for Proof of Stake (PoS) users and enable
developers to build innovative applications around Bifrosts’ liquid staking tokens.

### Bifrost dApp

Bifrost recent development of
SLPx,
is an extension pallet to Bifrost SLP that will allow users to invoke SLP's functionality on a
remote chain without crossing assets into the Bifrost chain, allowing users to mint, redeem, swap
vTokens remotely on the target chain. Leveraging this, developers can use and build innovative
solutions around chain abstraction and solving liquidity and user fragmentation challenges.

- Omni LS

Omni LS DApp
is a front-end application that supports remote minting and redemption of Bifrost liquid staking
tokens (LST) “vTokens”, as well as remote exchange, and swapping of vTokens from any chain. The DApp
aims to simplify the cross-chain experience by providing a seamless interface for users to interact
with vTokens across different chains natively.

### Build Parachains

Parachains are connected to and secured by the Relay Chain. They benefit from the _pooled security_,
_thought-through governance_, and overall _scalability_ of the heterogeneous sharding approach of
the network. Creating a parachain can be seen as creating a **Layer-1 blockchain**, which has its
own logic and runs in parallel within the
 ecosystem.

Developers can focus on creating state-of-the-art chains that take advantage of
's next-generation approach. Some
examples of what a parachain could be are:

- DeFi (Decentralized Finance) Applications
- Digital Wallets
- IoT (Internet of Things) Applications
- Gaming
- Web 3.0 Infrastructure

and more.

 aims to be a bet against blockchain
maximalism, where the success of 's
heterogeneous multi-chain approach will play a key part in the overall advancement of Web 3.0 and
decentralized systems. As a result, 's
parachain model was designed with the belief that the internet of the future will have many
different types of blockchains working together.

### What are the Benefits of Deploying a Parachain?

The parachain model attempts to alleviate five key _build_ failures of present technology stacks, as
described in the Polkadot Whitepaper:

- **Scalability**: How much is spent on resources and will the network be subject to bottlenecks?
- **Isolatability**: Are the needs of many accounted for under the same framework?
- **Developability**: Is the system tooling, system support, and overall system integrity
  dependable?
- **Governance**: Can the network remain flexible to evolve and adapt over time? Can decisions be
  made with sufficient inclusivity, legitimacy, and transparency to provide effective leadership of
  a decentralised system?
- **Applicability**: Does the technology address a burning need on its own? Is other “middleware”
  required to bridge the gap to actual applications?

#### Shared Security (Pooled Security)

Parachains can lease the security of the
 network by bonding
 for a parachain
slot. This means that the social costs of building a community around your project and convincing
validators to participate in your network security are reduced.
 has strong security, and
decentralised application projects wishing to benefit from this security would want to become a
parachain to share in that pooled security.

#### On-Chain Governance (Thought-through Governance)

Most governance systems in blockchains use an off-chain governance mechanism.
's on-chain governance encourages
maximum participation of token holders and is frictionless and transparent. It also enables
forkless upgrades.

#### Scalability

The sharded multichain network approach allows for what is essentially parallel computation
(processing power) that can process several transactions in parallel. Isolated blockchains are often
faced with the network constraint of processing transactions in sequence, causing bottlenecks.

#### Interoperability

Any decentralised application or chain that wants to enable trustless messaging to other parachains
already connected to  would want to
become a parachain. Interoperability between sovereign chains involves certain constraints and
complex protocols to enable across a wide breadth of chains.

With , you will get this feature out
of the box if you build your application as a parachain. The XCM format
allows any parachains to communicate by passing messages between them. Furthermore, as bridges to
other chains are connected (such as those to Bitcoin or Ethereum)
's parachains will be able to
communicate with these as well.

: an
abstract message passing system. Message passing is tracked on the relay chain - as such, you can
prove the delivery of messages and facilitate trustless interactions.

As you can place your blockchain’s latest block head, you can achieve deterministic finalization for
your chain. The hard part of reaching finalization for blockchains tends to be the consensus, where,
in the parachain model, a blockchain can offload consensus to the overall shared network, and focus
on block production. Since the validators have the Wasm runtime for all the parachains, your
parachain shares the security of the validator pool with everyone on the relay chain.

Any validator in the validator pool can help validate your blockchain.

## Things to Consider

### Para-nomics

#### Digital Nation States

Parachains can be seen as autonomous agents; networks that act as decentralised digital nation
states. Parachains have their own communities, rules, economies, governance, treasuries, and
relationships with external chains. As a result, the economic policies within parachain ecosystems
are subject to the developers and overall community of that parachain ecosystem; there isn't
necessarily a go-to economic model a parachain should follow.

Moreover, _becoming a parachain_ has an opportunity cost associated. Ideally, you can increase the
value of the network by participating in the parachain selection process, and this should serve as a
good return on investment.

#### Connecting Digital Economies

Collators act as network maintainers and maintain a full node of a
parachain. They can be incentivized with a native token payout from:

- Transaction fees collected
- Parachain token sponsorship

### Para-objects

:

- System level chains (permanent chains): leased slots
- Bridge Hubs
- Nested Relay Chains

### Migration

Projects that are already functioning as "solochains" or in isolated environments may be interested
in migrating onto  as a para-object.
While the parachain model has its benefits, it may not be the go-to strategy for some projects.

As a path for migration onto , it may
be more viable to migrate to one of the chains in one of the reserved slots.

For instance, there are currently options for smart contract deployment
on Kusama through the networks that have secured a slot in the latest slot auctions.

## Implement a Parachain

The Parachain Implementer's Guide is a significant work in progress and maintained by Parity Tech.
**The live version** is built from the source
located in the official
Polkadot repository.

### Parachain Development Kit

The Parachain Development Kit or **PDK** is a set of tools that allows developers to easily create a
parachain. In practice, the PDK will consist of the following key components:

- _State transition function_ : a way for your application to move from one state to another state.
- _Collator node_ : a type of peer-to-peer node in the {{ kusama:
  Kusama :kusama }} network with certain responsibilities regarding parachains.

#### Key Components

The state transition function (STF) can be an abstract way for an application to go from one state
to another state. The only constraint that
 places on this STF is that it must be easily verifiable -- usually
through what we call a _witness_ or _proof_. It must be so because the Relay Chain validators will
need to check that each state it receives from the collator node is correct without actually running
through the entire computation. Some examples of these proofs include the Proof-of-Validity blocks
or zk-SNARKs, which require less computational resources to verify than they do to generate. The
verification asymmetry in the proof generation of the STF is one of the integral insights that
allows  to scale while keeping
high-security guarantees.

A collator node is one of the types of network maintainers in the protocol. They are responsible for
**keeping availability** of the state of the parachain and the new states returned from the
iteration of the state transition function. They must remain online to keep track of the state and
also of the XCMP messages that it will route between itself and other parachains. Collator nodes are
responsible for passing the succinct proofs to the relay chain's validators and tracking the latest
blocks from the relay chain. In essence, a collator node also acts as a light client for the relay
chain. For more on collator nodes, see the collator page.

#### What PDKs Exist?

Currently, the only PDK is
Parity Substrate and
Cumulus.
**Substrate** is a blockchain framework that provides the basic building
blocks of a blockchain (things like the networking layer, consensus, a Wasm interpreter) while
providing an intuitive way to construct your runtime. Substrate is made to ease the process of
creating a new chain, but it does not provide support for
 compatibility directly. For this
reason, `Cumulus`, an added _library_ contains all of the
 compatibility glue code.

://docs.substrate.io/) maintained by
Parity Technologies.

://github.com/paritytech/polkadot-sdk/tree/master/cumulus) is an extension to
Substrate that makes it easy to make any Substrate-built runtime into a
-compatible parachain.

Cumulus Consensus is a consensus engine for Substrate that follows a
 Relay Chain (i.e., parachains). This
runs a  node internally, and dictates
to the client and synchronization algorithms which chain to follow, finalize, and treat as correct.

See the
Cumulus overview
for a more detailed description of Cumulus.

Cumulus is still in development, but the idea is that it should be simple to take a Substrate chain
and add the parachain code by importing the crates and adding a single line of code. Keep up-to-date
with the latest Cumulus developments from the Cumulus section.

: _state transition function_ and _collator node_.

Everything else is up to the implementer of the PDK.

:

- Cross-chain message passing (XCMP)
- Out-of-the-box Collator node setup
- An embedded full client of the Relay Chain
- Block authorship compatibility

Are you interested in building a PDK? See the future PDKs section for details.

### How to set up your parachain

After creating your chain runtime logic with Substrate, you will be able to compile it down to a
Wasm executable. This Wasm code blob will contain the entire state transition function of your
chain, and is what you will need to deploy your project to
 as a parachain.

Validators on  will use the submitted
Wasm code to validate the state transitions of your chain or thread, but doing this requires some
additional infrastructure. A validator needs some way to stay up to date with the most recent state
transitions, since  nodes will not be
required to also be nodes of your chain.

This is where the collator node comes into play. A collator is a maintainer of your parachain and
performs the critical action of producing new block candidates for your chain and passing them to
 validators for inclusion in the
 Relay Chain.

Substrate comes with its own networking layer built-in but unfortunately only supports solo chains
(that is, chains that do not connect to the relay chain). However, there is the Cumulus extension
that includes a collator node and allows for your Substrate-built logic to be compatible with
 as a parachain.

### Future PDKs

://grants.web3.foundation).

://ethresear.ch/t/roll-up-roll-back-snark-side-chain-17000-tps/3675) kit that allowed
developers to create SNARK-based parachains. If we review the roll-up write-up, we see that the
system uses two roles: users that update **state** and an operator that **aggregates the state
updates** into a single on-chain update. It should be straightforward to see how we can translate
this to the parachain terms. The state transition function for a roll-up-like parachain would be
updating the state (in practice, most likely a Merkle tree, which would be easily verifiable) from
the user inputs. The operator would act as the collator node, which would aggregate the state and
create the zk-SNARK proof that it would hand to a Relay Chain's validators for verification.

If you or your team are interested in developing a PDK feel free to apply for a grant on the
W3F Grants Program repository. There may be grants
available for this type of work.

## Testing a Parachain

### Rococo Testnet

Rococo is a testnet built
for testing parachains. Rococo utilizes Cumulus and
HRMP (Horizontal Relay-routed Message Passing) in
order to send transfers and messages between parachains.

Rococo runs a few test system parachains, like
Asset Hub,
Contracts,
Coretime,
Encointer Lietaer,
and
Bridge Hub.
It also runs several externally developed parachains.

### What Parachains are on Rococo Now?

You can see the list of included parachains
here. A list of
proposed parachains is available
here.

### Obtaining ROC

Follow the instructions here to get
ROCs tokens.

### How to Connect to a Parachain

If you would like to connect to a parachain via Polkadot-JS Apps,
you may do so by clicking on the network selection at the top left-hand corner of the navigation and
selecting any parachain of choice.

!rococo parachains

For the purpose of these following examples, we will be using the Rococo testnet "Custom Node"
underneath "Development", following the
parachain tutorials.

### Parachain Playground

You can also take advantage of the account functions offered on Polkadot-JS Apps to test the entire
Parachain onboarding process (e.g. crowdloans, auctions, registrations).

Start a local node on Westend by running:

```bash
polkadot --chain=westend-dev --alice
```

Then, connect your local node with Polkadot-JS Apps.

!parachains playground

## Deploy

Substrate-based chains, including the Polkadot and Kusama Relay Chains, use an
SS58 encoding for their address formats.
This page serves as the
canonical registry for teams to see which chain corresponds to a given prefix, and which prefixes
are available.

### Parachain

To include your parachain into the
network, you will need to acquire a parachain slot.

Parachain slot leases are acuqired through open auctions, the mechanics of which can be found on the
parachain auction page. With
Agile Coretime, these parachain lease auctions will be
deprecated and parachains can purchase coretime to
produce blocks
continuously or on-demand.

## Resources

- Parachain tutorials
- System (Common Good) Parachains
- The Launch of Parachains
- Parathreads: Pay-as-you-go Parachains
- Polkadot Bridges
- The Path of a Parachain Block
- The Path of a Parachain Block (Video)
- Polkadot Parachain Slots
- How to become a parachain on Polkadot (Video)
- Trusted Execution Environments and the Polkadot Ecosystem

### Learn Nomination Pools

://polkadot.network/blog/nomination-pools-are-live-stake-natively-with-just-1-dot/).
Note that rewards are not guaranteed for those pools that do not have enough bonded funds to be
included within the bags list. **Only members of active
pools will receive rewards.**

There are currently


members in


pools. There is no limit to the number of pools or pool members per pool.

:** Joining a nomination pool is possible only with the XL version of the Polkadot
Ledger App. This should be installed by default on Ledger Nano X and S Plus, but not on the Nano S.

**If you become a nomination pool member or a pool admin, you cannot participate in Governance with
the bonded tokens in the pool, as they are held in a
system account.**

://dot.li/discord) for asking general questions about
Nomination Pools. If you are a developer, please join our
nomination pools support channel.

: Tracks the distribution of actively staked funds.
- Reward Pool: Tracks rewards earned by actively staked funds.
- Unbonding Sub Pools: Collection of pools at different phases (i.e. eras) of the unbonding
  lifecycle.
- Members: Accounts that nominate to the pools.
- Point: Unit of measure for a member’s portion of a pool's funds. All pools start with a point to
  Planck ratio of 1. Over time, if the pool receives rewards, they increase in value, and if the
  pool is slashed, it decreases in value.

## Pool Member Lifecycle

### Join a pool

A member delegates funds to a pool by transferring some amount to the pool’s bonded account with the
`join` extrinsic. The pool then increases its bond with the new funds. A member is afforded the
ability to bond additional funds or re-stake rewards as long as they are already actively bonded.
Note that a member may only belong to one pool at a time.

**The current minimum bond to join a pool on**




://github.com/paritytech/polkadot/pull/7448) are
released on the network.

Thus, depending on how much control you want to give your proxy, you might choose between
non-transfer > staking > nomination pool proxy, with the latter being only able to sign transactions
related to the `NominationPool` pallet.

://support.polkadot.network/support/solutions/articles/65000181401-how-to-join-nomination-pools)
for guidelines.

### Claim rewards

The member can claim their portion of any rewards that have accumulated since the previous time they
claimed (or in the case that they have never claimed, any rewards that have accumulated since the
era after they joined). Rewards are split pro rata among the actively bonded members. Check the "How
to claim rewards" section in
this support article
for guidelines.

### Claim Permissions

As a pool member, you can grant permission to any other account to claim and compound rewards on
your behalf. There are four permission options:

- `Permissioned` (default): you need to claim and compound your rewards.
- `PermissionlessCompound`: you grant permission to any other account to compound (claim and bond)
  your rewards on your behalf.
- `PermissionlessWithdraw`: you grant permission to any other account to withdraw (claim and keep as
  a free balance) your rewards on your behalf.
- `PermissionlessAll`: you grant permission to any other account to compound or withdraw your
  rewards on your behalf.

See the Staking Dashboard page for more information about
how to set your claim permissions.

See the advanced guides to
learn how to claim rewards for another pool member.

### Unbond and withdraw funds

At any point in time after joining the pool, a member can start the process of exiting by unbonding.
`unbond` will unbond part or all of the member's funds. After unbond has been called and the
unbonding duration has passed


eras which correspond to


days on   a member may withdraw
their funds with `withdrawUnbonded`. Withdrawing effectively ends a member's relationship with their
pool, allowing them to join a different pool if desired. Check the "Withdraw unbonded funds" section
in
this support article
for guidelines.

: The pool is open to be joined by anyone.
- Blocked: The pool is blocked; no joiners are permitted.
- Destroying: The pool is in the process of being destroyed. Once in this state, the pool may never
  revert to any other state; it can only proceed to be destroyed. All members can be
  permissionlessly unbonded; this allows the pool to be dismantled regardless of any member’s
  proactivity.

### Roles

- Depositor: Creates the pool and is the initial member. The depositor can only leave the pool once
  all other members have left. Once they leave by withdrawing, the pool is fully removed from the
  system.
- Nominator: Can select the validators the pool nominates.
- Bouncer: Can change the pool’s state and kick (permissionlessly unbond/withdraw) members if the
  pool is blocked.
- Root: Can change the nominator, bouncer, or itself. Further, it can perform any of the actions the
  nominator or bouncer can.

### Pool Commissions

As the pool root role, you can set pool commissions that will be applied to the staking rewards paid
out to the pool's system account before rewards are allocated for the pool members. You can set pool
commissions through the Polkadot Staking Dashboard.

Three methods can be used when setting the pool commission:

- **Commission Rate** (`nominationPools.setCommission` extrinsic): the start or new commission rate
  (`newCommission` parameter) that can be set between 0% and
  %
  (decided through governance referendum) via the
  `globalMaxCommission`
  parameter. You will need to specify an Input Payee Account, i.e. the account that will receive the
  commission.
- **Max Commission** (`nominationPools.setCommissionMax` extrinsic): the maximum commission
  (`maxCommission` parameter) the pool will apply to its members (between 0% and Max Commission).
  Note that once set, **the pool admin can only lower it**.
- **Change Rate** (`nominationPools.setCommissionChangeRate` extrinsic): the maximum rate increase
  (`maxIncrease` parameter) allowed for a single commission update. Note that once set, **the pool
  admin can only lower it**. When setting the Change Rate, it will also be possible to set a
  `minDelay` quantified as the number of blocks (since last commission update) after which it is
  possible to change the commission (i.e. the minimum delay between commission updates). Note that
  once set, **the pool admin can only increase it**.

Max Commission and Change Rate must not be necessarily set. It is the choice of the pool admin to
set those parameters and provide transparency to the pool members about the pool's commission
policy.

:

- The pool commission can be increased by 1% every 30 minutes. Bigger increases are not allowed.
  Increases of less than or equal to 1% are not allowed sooner than 30 minutes since the last
  commission update.
- The Max Commission can only be decreased from 100%. Once decreased, it can be decreased again but
  it cannot be increased.
- The Change Rate's maximum increase can only be decreased from 1%. Once decreased, it can be
  decreased again but it cannot be increased.
- The Change Rate's minimum delay between updates of 30 min can only be increased. Once increased,
  it can be increased again but it cannot be decreased.

## Pool Lifecycle

: if a pool's validators
attack the network, their members need to unbond fast! Avoiding additional slashes gives them an
incentive to do that if validators get repeatedly slashed.

## Nominating vs Joining a Pool

Nominating is the action of choosing validators. It does not simply involve bonding tokens.
Nominating is an active task, which implies that you regularly monitor that your stake is backing an
active validator in all the eras and check if you are receiving your staking rewards. More
importantly, ensure that the validators you chose always act in the best interests of the network
protocol and have less chance of getting slashed. To nominate, you need a minimum of
,
and to receive rewards, you need at least a balance greater than the minimum active bond. If the
validator misbehaves, It is worth noting that your stake is subject to slashing, irrespective of
whether you are at the top nominators or not.

As the minimum active bond is a dynamic value, it can make your nomination inactive when the
threshold goes above your bonded balance. Hence, to be eligible to earn rewards while nominating,
you would need to stake a much higher balance than the minimum active bond.

Nomination pools are a way to participate in staking with as little as 1 DOT and earn staking
rewards. Nomination pools differ from custodial solutions (like staking through central exchanges)
because they are non-custodial, native to Polkadot's protocol, permissionless, transparent, and run
in a decentralized way by the community. Before joining a nomination pool, you must ensure that the
pool is earning rewards and nominating the validators that match your preferences. Participating in
pools is more of a set-and-forget action than nominating by yourself. The pool operator maintains
the list of validators nominated by the pool, and so, in a way, you are trusting the pool operator
to act in your best interests. However, it is advised to check the validators nominated by the pool
from time to time and change the pool if necessary.

://polkadot.network/blog/nomination-pools-are-live-stake-natively-with-just-1-dot/).
Check the wiki doc on nomination pools for more information.

:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|                                                                                                                        Minimum 250 DOT to nominate.                                                                                                                         |                                                                                                       Minimum 1 DOT to be a member.                                                                                                       |
|                                                                                                       Rewards can be compounded automatically or sent to any account.                                                                                                       |                                                              Rewards can be manually claimed to the pool member's account and be bonded in the pool again to compound them.                                                               |
|                                                                                           If the active validator gets slashed, all active nominators are subjected to slashing.                                                                                            |                                                                             If the active validator gets slashed, all pool members are subjected to slashing.                                                                             |
|                                                                                                                    Can bond and stake DOT indefinitely.                                                                                                                     |                                                                                               Can bond and stake DOT until the pool exists.                                                                                               |
|                                                                                                    Unbonding period of 28 days. Can switch validators without unbonding.                                                                                                    |                                                                             Unbonding period of 28 days. Need to unbond before switching to a different pool.                                                                             |
|                                                                                                                              Maximum uncapped.                                                                                                                              |                                                                                                             Maximum uncapped.                                                                                                             |
| Should bond more than the minimum active nomination in an era to be eligible to earn staking rewards, although it can depend on multiple other factors outlined in the linked document. |           A nomination pool earns rewards in an era if it satisfies all the conditions mentioned for the nominator (as the nomination pool is just a nominator from the NPoS system perspective).           |
|                                                                                                         Staked tokens can be used for participation in Governance.                                                                                                          |                                                                                       Staked tokens cannot be used for participation in Governance.                                                                                       |
|                                                            Rewards payout can be triggered permissionlessly by anyone (typically done by the validator).                                                             | A pool member can self claim the rewards or can grant permission to any other account to claim and compound rewards on your behalf. See Claim Permissions. |
|                                                                                                                    Bonded funds remain in your account.                                                                                                                     |        Bonded funds are transferred to a pool account which is administered by the network protocol and is not accessible to anyone else. See System Accounts for more information.        |
|                                                                                                         Nominator manages the list of staked validators (up to 16).                                                                                                         |                                                                                                 Nominations managed by the pool operator.                                                                                                 |

## Tools & Utilities

### Build Tools Index

Here, we provide a list of tools available for your development needs. They are sorted by context.
If you're actively maintaining a tool that might be useful to other Polkadot, Kusama or Substrate
developers, feel free to add it in.

## Wallets

Please see the Wallets page on the official website
or the Wallets page on the Wiki for detailed information.

## Block Explorers

- Polkadot-JS Apps Explorer - Polkadot dashboard block
  explorer. Supports dozens of other networks, including Kusama, Westend, and other remote or local
  endpoints. Access via IPFS
- Subscan - Blockchain explorer for Substrate chains.
  Repo.
- 3xpl.com - Fastest ad-free universal block explorer and JSON API with
  Polkadot support.
- Blockchair.com - Universal blockchain explorer and search
  engine with Polkadot support.
- Statescan.io - Polkadot & Kusama Blockchain explorer.

## Blockchain Analytics

- Dune Analytics - Community dashboards and analytics
- DotLake - data visualizations for the Polkadot Ecosystem
  maintained by Parity
- Web3go - An open platform for everyone to play with, curate and
  visualize multi-blockchain data
- Polkawatch - Polkadot Decentralization Analytics

## Network Monitoring & Reporting

- Polkadot Telemetry Service - Network information including what
  nodes are running the chain, what software versions they are running, sync status, and location.
- Polkabot - Polkadot network monitoring and reporting using Matrix
  (Riot / Element) chat. Users may create custom bot plugins.
  Blogpost.
- Ryabina's Telegram Bot - A Telegram bot for
  monitoring on-chain events of Substrate chains.
  GitHub Repository
- PolkaStats - Polkadot network statistics (includes Kusama). Shows
  network information and staking details from validators and intentions.
  GitHub Repository.
- Panic - A node monitoring and alert server for validators.
- OpenWeb3/Guardian - A CLI tool and JS library to
  monitor on chain states and events.
- Ocelloids SDK - Typescript SDK for multi-chain monitoring
  that supports domain-specific logic for different pallets.
- Cyclops Dashboard - a validator dashboard application
  that helps Polkadot network validators keep track of all their validators, their staking rewards,
  and performance.

## Clients

- Polkadot - The original Rust
  implementation of the Polkadot Host.
- Kagome - A C++ Polkadot implementation of the Polkadot Host
  developed by Soramitsu.
- Gossamer - A Go implementation of the Polkadot Host
  developed by ChainSafe Systems.
- TX Wrapper - Helper functions for offline transaction
  generation.

## Tools

- Substrate - Blockchain
  development platform written in Rust. The Rust version of the Polkadot Host is being built with
  Substrate.
- Substrate Docs - Comprehensive documentation and tutorials for
  building a blockchain using Substrate.
- Substrate VSCode plugin.
- Substrate Debug Kit - A collection of debug
  tools and libraries around substrate chains. Includes tools to calculate NPoS elections offline,
  disk usage monitoring, test templates against chain state and other pallet-specific helper.
- POP CLI - An all-in-one tool for Polkadot development.
- Diener - A tool for easy changing of Polkadot or Substrate
  dependency versions.
- Polkadot Launch - A tool to easily launch
  custom local parachain-enabled Polkadot versions.
- Halva - A Truffle-inspired local development environment
  for Substrate.
- Fork-off Substrate - Copies the state of an
  existing chain into your local version and lets you further experiment on it.
- srtool - A tool for verifying runtime versions against
  on-chain proposal hashes.
- sub-bench - A tool to spam your node with transactions for
  the sake of benchmarking.
- substrate-devhub-utils - A set of
  JavaScript utilities making life with Substrate a little easier.
- sub-flood - A tool to benchmark Substrate by flooding it
  with requests.
- Apillon - A Web3 development platform with a complete toolbox and
  access to Polkadot’s technology stack.

## IDEs

- Astar IDE by
  Chain IDE is a tool for lightning-speed smart contracts and dApp
  development for Wasm and
  EVM.
- Sandox IDE is an integrated development environment (IDE)
  with tools for building in the Polkadot environment. Currently helpful for creating applications
  in JS.

## UI

- Polkadash - VueJS-based starter kit for custom user
  interfaces for Substrate chains.
- Polkadot JS Apps UI - Repository of the
  polkadot.js.org/apps UI.
- Substrate Front-end Template -
  ReactJS-based starter UI for custom user interfaces for Substrate chains.
- Polkadot JS Browser Extension - Key management in a
  Chrome extension.
- Polkadot UI - A library and platform for developing and publishing
  assets for Polkadot dapps.

## Libraries

### Polkadot-JS API

The Polkadot-JS API provides various utility functions that are used across all projects in the
`@polkadot` namespace and is split into a number of internal utility packages. The documentation and
usage instructions are provided at Polkadot-JS API Documentation.

- @polkadot/keyring This allows you to create and load
  accounts in JavaScript. It is helpful for creating wallets or any application that will require
  the user to write to chain. Examples.
- @polkadot/util Utility
  functions like checking if a string is hex-encoded.
- @polkadot/util-crypto Useful cryptographic utilities
  for developing with Polkadot.

### Alternative Libraries

The following libraries/SDKs allow for interfacing with a Substrate node in other languages:

- Python Library by Polkascan
- Go Library by Centrifuge
- Java Library by StrategyObject
- Fearless Utils iOS Swift SDK
- Nova Wallet iOS/Swift Substrate SDK
- Kotlin SDK
- Dart/Flutter Library

### CLI Tools

- @polkadot/api-cli Command
  line interface for the polkadot API. Documentation.
- @polkadot/monitor-rpc An
  RPC monitor for Polkadot. See the RPC tools below for additional information.
- @polkadot/signer-cli A
  Tool to construct, sign, and broadcast transactions. Signing can be done offline.
- Polkadot API Cpp - A С++ API for Polkadot, can
  build `clip`, a command line tool.
- Subkey - Command line utility
  for generating and inspecting key pairs.

### WASM

WebAssembly related tools and projects.

- ink! - An eDSL to write WebAssembly based smart contracts
  using the Rust programming language.
- parity-wasm - Low-level WebAssembly format library.
- wasm-utils - Collection of WebAssembly utilities used
  in pwasm-ethereum and substrate contract development.
- wasmi - A WebAssembly interpreter conceived as a component
  of parity-ethereum (Ethereum-like contracts in Wasm) and Substrate.

### RPC and API Tools

- @polkadot/api/rpc-provider
  Demonstrates how the JS tools interact with the node over RPC.
- RPC documentation - Documentation of Substrate RPC
  methods.
- Polkadot API Server by SimplyVC - A wrapper
  around the Polkadot API which makes it easier to make Polkadot API calls from any programming
  language.
- Go: Subscan API - Go API for Polkadot.
- C++ Polkadot API - С++ API for Polkadot.
- .NET Polkadot/Substrate API - Core
  Framework for Substrate in .NET and connect to nodes.
- .NET Toolchain Polkadot/Substrate API -
  Toolchain to generate Polkadot/Substrate API & Service Layer for .NET.
- .NET Polkadot API - Polkadot Substrate API
  for .NET.
- Python Polkadot API - Polkadot library for
  Python.
- GSRPC - Substrate RPC client in Go,
  a.k.a. GSRPC.
- Substrate API Sidecar - An HTTP wrapper for
  Substrate, abstracting some complex RPC calls into simple REST calls.
- Subxt - A Rust library to submit extrinsics to a
  Substrate node via RPC.

### GAME ENGINE SDK

- Polkadot SDK for Unity - A powerful toolkit
  that integrates substrate seamless into Unity projects.
  (AssetStore,
  wiki).

### SCALE Codec

The SCALE (Simple Concatenated Aggregate Little-Endian) Codec is a lightweight, efficient, binary
serialization and deserialization codec.

It is designed for high-performance, copy-free encoding and decoding of data in resource-constrained
execution contexts, such as the Substrate runtime. It is not self-describing in any way and assumes
the decoding context has all type knowledge about the encoded data.

It is used in almost all communication to/from Substrate nodes, so implementations in different
languages exist:

- Substrate Awesome
  maintains a list of SCALE codex implementations.

## Data Crawling and Conversion

The following tools help you extract and structure data from a Substrate node.

- Parity's Substrate Archive - Can be run
  alongside a Substrate node to archive all blocks, state, and extrinsic data into PostgreSQL
  database.
- Subsquid Archives - Generate a GraphQL database
  from a Substrate chain's data with rich filtering and querying capabilities. The data (events,
  extrinsics, blocks) for most parachains is readily available though public archive GraphQL
  endpoints, kept in
  Squid Archive Registry
- Polka-store - A tool which scans a Substrate chain
  and stores balance-relevant transactions in an SQLite database.
- Substrate-graph - A compact indexer for Substrate
  based nodes providing a GraphQL interface.

### Learn Asset Conversion Assethub

Asset conversion is a simple AMM (Automated Market Maker) based on
Uniswap V2 logic, deployed as a
pallet on Polkadot AssetHub.
In the AMM model the prices of tokens are determined by a mathematical formula based on the ratio of
tokens in a liquidity pool, unlike traditional exchanges that use an order book. This will be a
“trustless” DEX, controlled through Polkadot OpenGov.

:

- create a liquidity pool
  with  and an asset
- provide the liquidity
  and receive back an LP token
- exchange the LP token back to assets
- swap assets if there is a pool created
- query for an exchange price
  via a runtime call endpoint
- query the size of a liquidity pool.

://github.com/paritytech/polkadot-sdk/tree/cdc8d197e6d487ef54f7e16767b5c1ab041c8b10/substrate/frame/transaction-payment/asset-conversion-tx-payment),
allowing runtimes that include it to pay for transactions in assets other than the native token of
the chain.

:

- The exchange/custodian only needs to transact on one parachain and can access every other without
  any infrastructure lift.
- For the user, they never actually need to “see” AssetHub. It’s entirely abstracted away behind
  either the parachain wallet/application or the exchange/custodian.

### Learn Guides Assets Create

import MessageBox from
"../../components/MessageBox";



The Asset Hub is a generic assets system parachain which provides functionality for deploying and
transferring assets — both Fungible and Non-Fungible Tokens (NFTs). The native token of the Asset
hub is . The Existential Deposit (ED),
transaction fees, and the deposits for proxy/multisig operations are about 1/10th of the values on
the Relay chains. For example, the Existential Deposit of an Asset Hub account is


when compared to

.
Apart from the core protocol token , the
assets held on the Asset Hub can be broadly categorized as

- Assets backed by an on-chain protocol’s utility
- Assets with off-chain backing
- Assets without any backing

For additional background on the Asset Hub check out
this support article.

## Creating Assets on the Asset Hub with Polkadot-JS

://wiki.polkadot.network/docs/learn-DOT#getting-westies).

**The images in the guides below are for Polkadot, but they also apply to Kusama.**

://polkadot.js.org/apps/#/explorer).
- Navigate to Network > Assets.

!Navigate to Assets page

- Click on the create button and you will be presented with a pop-up window. Choose the creator
  account, name of the asset to be displayed on the Asset Hub, the asset's symbol, number of
  decimals for the asset, the minimum balance required to hold this asset on an Asset Hub account
  and the most important field of your asset - the unique asset ID. The UI would not let you enter
  an ID that has already been taken. After all the details are entered, click on the next button.

!Add Asset Metadata

- Choose the admin, issuer and the freezer accounts for your asset and click on the create button.

!Asset managing accounts

- Sign and submit the transaction (If you like to verify the transaction details before signing, you
  can click on the dropdown button pointed by the arrow in the snapshot below).

!Sign asset creating transaction

If the transaction is successful, you should see the asset and its details displayed in the
Network > Assets page on the Asset Hub.

### Learn Guides Assets Ledger

://www.ledger.com/) application that is compatible with the Ledger
Nano S and Ledger Nano X devices. The Ledger devices are hardware wallets that keep your private key
secured on a physical device that does not get directly exposed to your computer or the internet.

The Statemine application allows you to manage your KSM and other tokens on the Asset Hub parachain.
It supports most of the available transaction types of the network in the XL version of the app
(details below).

If you have trouble using Ledger or following the directions below, you can try searching for your
issue on the Polkadot Support page.

://youtu.be/7VlTncHCGPc).

:

- A Ledger Nano S or a Ledger Nano X.
- The latest firmware installed.
- Ledger Live is installed and at version 2.29 or newer (see settings -> about to find out if you're
  up to date).
- A web browser is installed that you can use to access
  Polkadot-JS Apps UI.

## Installing the Ledger Application

### Using Ledger Live

: the normal (light) version and the XL version. The
light version has smaller size but it supports only basic functionality. If you want access to all
the supported extrinsics, you need to install the XL version of the app. You can see
here a full list of the extrinsics supported by both
versions.

://polkadot.js.org/apps/#/explorer) already has an integration with the
Ledger application so that your device will work with the browser interface after installation. The
functionality is currently gated behind a feature setting that you will need to turn on.

In order to turn on the interoperability with the Statemine Ledger application, go to the "Settings"
tab in Polkadot-JS Apps UI. Find the option for attaching
Ledger devices and switch the option from the default "Do not attach Ledger devices" to "Attach
Ledger via WebUSB" (**but see note above**).

!Dropdown selector for allowing Ledger connections in Polkadot-JS Apps UI Settings

Click "Save" to keep your settings.

Now when you go to the "Accounts" tab you will see a new button that says "Add via Ledger". Ensure
that your Ledger device is unlocked, Ledger Live is **closed** and you have
switched over
to the Statemine application, then click this button.

!Add Ledger button in Polkadot-JS Apps UI

A popup will appear asking you to select an account and derivation path.

!Picking an account and derivation path

The first option lets you select an account. You can have multiple accounts on a single Ledger
device. The second dropdown lets you pick a derivation path - think of it like a formula from which
child accounts are generated. If in doubt, pick the default option for both.

Once you confirm your selection, depending on your browser and its security settings, you might need
to confirm the USB connection through a popup like the one below when adding the Ledger device for
the first time:

!Display the device connection popup

You should now be able to scroll down and find a new account on the page with the type "ledger".

!Displaying the Ledger account in the list

You can now use this account to interact with the Asset Hub on
Polkadot-JS Apps UI and it will prompt your ledger for
confirmation when you initiate a transaction.

### Working on Relay Chains and Asset Hubs

Polkadot and Kusama accounts from the extension
will show up in the Asset Hub, even if they're not set to be used on all chains. The Asset Hub is a
system parachains on  and uses
 as native token. Hence, accounts on a Relay
Chain are also available on each Relay's system chains. What this means is that if you already have
a  Ledger account configured on the
extension, that account will also be available on the Asset Hub. But the opposite is not the case:
an account created specifically on the Asset Hub won't show up on
.

**However**, as mentioned above, the
Polkadot extension does not support Statemine
Ledger accounts at the moment, but the Polkadot-JS UI does. So, if your Kusama account is in the
Polkadot extension, you'll need to remove it from there and re-add it on Polkadot-JS UI directly
**as a Kusama account**, as described
here. After that,
you will be able to make transactions with that account.

To remove an account from the Polkadot extension:

1. Open the extension
2. Click on the three dots next to the account
3. Select "Forget account".

://polkadot.js.org/apps/#/explorer).

#### Using Polkadot-JS Apps

Once you have your account loaded on the "Accounts" tab it should show a row with your Ledger
account. At the far right of the row is located your account's DOT balance. If you expand the
balance arrow, it will show details of your balance such as locks or reserved amounts.

!Account row showing empty balance

### Sending a Transfer

If you would like to send a transfer from your account housed on the Ledger device, the easiest
method is to use Polkadot-JS Apps UI.

:

- Create an account outside your Ledger. Instructions can be found
  here.
- Transfer the desired amount as described above. If you want to send exactly
  the amount you want to teleport, don't forget take into account the fees for teleporting that will
  be deducted in the next step.
- Teleport your tokens following the instructions you will find here.

Teleporting **to** a Ledger account from a non-Ledger account doesn't require these extra steps.

## Support

If you need support, please visit the Polkadot Support page.

### Learn Guides Assets



### Learn Assets

Assets in the  network can be
represented on several chains. They can take many forms, from a parachain's native token to on-chain
representations of off-chain reserves. This page focuses on the latter, namely assets issued by a
creator (e.g. rights to audited, off-chain reserves held by the creator, or art issued as an NFT).

The
Asset Hub system parachain
hosts data structures and logic that specialize in the creation, management, and use of assets in
the  network. Although other
parachains can host applications dealing with assets on the Asset Hub, the hub can be thought of as
the "home base" of assets in the network.

The Asset Hub uses  as its native token. The
chain yields its governance to its parent Relay Chain and has no inflation or era-based rewards for
collators (although collators receive a portion of transaction fees). As a
system parachain,
the Asset Hub has a trusted relationship with the Relay Chain, and as such, can teleport
 between itself and the Relay Chain. That is,
 on the Asset Hub is just as good as
 on the Relay Chain.

The Asset Hub does not support smart contracts. See the Advanced section at
the bottom for a discussion on using proxy and multisig accounts to replicate oft-used contract
logic.

## Sufficient Assets

A sufficient asset on Asset Hub can allow for an account to exist on-chain even though it does not
have any account balance in . Any registered
asset on the Asset Hub can be made _sufficient_ through governance on the Relay Chain. A balance of
a non-sufficient asset can only exist on accounts that are on-chain (i.e., accounts having the
existential deposit of a sufficient asset).
That is, a user could not keep an account on-chain by transferring an non-sufficient asset to it;
the account must already be on-chain by having more than the existential deposit in
 (or a sufficient asset).

Assets deemed _sufficient_ can instantiate accounts on the Asset Hub and pay for transaction fees
without the need for  An example would be
USDT on the Polkadot Asset Hub. If an account holds 0.7 USDT, it would exist on the Polkadot Asset
Hub system parachain without the need to hold DOT.

://youtu.be/knNLZEyposM?list=PLOyWqupZ-WGuAuS00rK-pebTMAOxW41W8&t=63)
to learn how to create fungible assets on the Asset Hub.

:

- The **owner** can set the accounts responsible for the other three roles and set asset metadata
  (e.g. name, symbol, decimals).
- The **issuer** can mint and burn tokens to/from their chosen addresses.
- The **admin** can make force transfers as well as unfreeze accounts of the asset class.
- The **freezer** can freeze assets on target addresses or the entire asset class.

Always refer to the **reference documentation**
for certainty on privileged roles.

An asset's details contain one field not accessible to its owner or admin team,
asset sufficiency.

://github.com/polkadot-js/apps/issues/7812).
When using Polkadot-JS UI, transaction fee needs to be paid in
.

://youtu.be/knNLZEyposM?list=PLOyWqupZ-WGuAuS00rK-pebTMAOxW41W8&t=326)
to learn how to transfer assets on the Asset Hub.

For Ledger users see this video tutorial to learn how to use the
Statemine Ledger app and what its current limitations are.

://support.polkadot.network/support/solutions/articles/65000181118-how-to-transfer-tether-usdt-on-statemine)
to learn more about transferring assets using the Asset Hub.

://youtu.be/knNLZEyposM?list=PLOyWqupZ-WGuAuS00rK-pebTMAOxW41W8&t=422)
to learn how to destroy assets on the Asset Hub.

:

- `assets.freezeAsset` will freeze all assets on all accounts holding that asset id. Those accounts
  will no longer be able to transfer that asset.
- `assets.startDestroy` will start the destroying process.
- `assets.destroyApprovals` will destroy all approvals related to that asset id (if there are any
  approvals).
- `assets.destroyAccounts` will destroy all accounts related to that asset id. All asset units will
  be removed from those accounts.
- `assets.finishDestroy` will finish the destroying process. The asset id will be removed and
  available for another fungible token.

### Application Development

The Asset Hub provides an `approve_transfer`, `transfer_approved`, and `cancel_approval` interface.
Application developers can use this interface so that users can authorize the application to
effectuate transfers up to a given amount on behalf of an account.

### Cross-Chain Accounting

The Asset Hub uses a reserve-backed system to manage asset transfers to other parachains. It tracks
how much of each asset has gone to each parachain and will not accept more from a particular
parachain.

As a result of this, asset owners can use the Asset Hub to track information like the total issuance
of their asset in the entire network, as parachain balances would be included in the reserve-backed
table. Likewise, for the minting and burning of tokens, an asset's team can perform all operations
on the Asset Hub and propagate any minted tokens to other parachains in the network.

Parachains that want to send assets to other parachains should do so via instructions to the Asset
Hub so that the reserve-backed table stays up to date. For more info, see the "Moving Assets between
Chains in XCM" section of the
article on the XCM format.

## Non-Fungible Assets

Unlike fungible assets, the particular instance of a non-fungible asset (NFT) has
a separate meaning from another instance of the same class. The Asset Hub represents NFTs in the
Uniques and NFTs pallets.

Similar to the Assets pallet, this functionality is encoded into the chain. Operations are
benchmarked before each release instead of any runtime metering, ensuring efficient execution and
stable transaction fees.

### Transferring NFTs

Users can transfer their NFTs to other accounts. The chain also provides an `approve_transfer`,
`transfer_approved` and `cancel_approval` interfaces that application developers can use to allow
users to authorize an application to transfer an instance on their behalf.

## Advanced Techniques

Many asset creators on other networks use smart contracts to control privileged functions like
minting and burning. Although the Asset Hub does not have a smart contract interface, it contains
the Multisig,
Proxy, and
Utility pallets, which will meet most account
management needs.

For example, if a team wants sign-off from two groups to perform a privileged operation, it could
create a 2-of-2 **multisig** from two
**pure proxies**, and then set members from
each group as proxies to those two accounts.

### Learn Guides Asset Conversion

://github.com/MVPWorkshop/dot-acp-ui) project is part of Polkadot initiative
for building front-end and UI for Asset Conversion Pallet on Polkadot's Asset Hub. Currently, the
app is deployed on Westend, Rococo and Kusama here.

::PoolCreated` event. After creating a pool,
liquidity can be added to it via the `Pallet::add_liquidity` function.

For example, the snapshot below shows how to create liquidity pool with `ROC` tokens and `EDU`
tokens with the asset ID `149` on Rococo Asset Hub. Creating this extrinsic requires knowledge of
XCM Multilocations. From the perspective of AssetHub,
an Asset Hub, the asset with an `AssetId` of `149` has a MultiLocation of

```
{
   parents: 0,
   interior: {
     X2: [{PalletInstance: 50}, {GeneralIndex: 149}]
   }
}
```

The PalletInstance of `50` represents the Assets pallet on Asset Hub and the `GeneralIndex` is the
`AssetId` of the asset.

!Create Liquidity Pool

The `lp_token` ID created for this pool is `24`, and
here is the event for
reference.

## Liquidity Provision

The `add_liquidity` function allows users to provide liquidity to a pool composed of two assets. It
requires specifying the desired amounts for both assets and minimum acceptable amounts. The function
calculates an optimal contribution of assets, which may differ from the desired amounts but will not
be less than the specified minimums. Liquidity providers receive liquidity tokens representing their
share of the pool.

For example, the snapshot below shows how to provide liquidity to the pool with `ROC` tokens and
`EDU` tokens with the asset ID `149` on Rococo Asset Hub. The intention is to provide liquidity of 1
`ROC` token (`u128` value of `1000000000000` as it has 12 decimals) and 100 `EDU` tokens (`u128`
value of `1000000000000` as it has 10 decimals).

!Provide Liquidity

After successful submission of the extrinsic above, LP tokens are minted to the specified account.
Below is the snapshot of the liquidity pool on the
DOT ACP UI.

!Liquidity Pool Example

## Swap Assets

### Swap from an exact amount of Tokens

The `swap_exact_tokens_for_tokens` function allows users to swap a precise amount of one asset for
another within a specified liquidity pool, ensuring the user receives at least a minimum expected
amount of the second asset in return. This function aims to provide predictability in trading
outcomes, allowing users to manage their asset exchanges with confidence regarding the minimum
return.

For example, the snapshot below shows how to swap `ROC` tokens to `EDU` tokens with the asset ID
`149` on Rococo Asset Hub. The intention is to swap 0.1 `ROC` tokens (`u128` value of `100000000000`
as it has 12 decimals) to at least 9 `EDU` tokens (`u128` value of `90000000000` as it has 10
decimals).

!Swap Exact Amount

Below is the snapshot of the liquidity pool on the
DOT ACP UI. after successful submission of the
extrinsic above. It can be observed that the pool now has 1.1 `ROC` tokens and around 9.06 `EDU`
tokens are transferred out of it.

!Swap Exact Amount Example

### Swap to an exact amount of Tokens

On the other hand, the `swap_tokens_for_exact_tokens` function allows users to trade a flexible
amount of one asset to precisely obtain a specified amount of another asset. It ensures that users
do not spend more than a predetermined maximum amount of the initial asset to acquire the exact
target amount of the second asset, providing a way to control the cost of the transaction while
achieving the desired outcome.

For example, the snapshot below shows how to swap `EDU` tokens with the asset ID `149` on Rococo
Asset Hub to `ROC` Tokens. The intention is to swap for obtaining 0.1 `ROC` tokens (`u128` value of
`100000000000` as it has 12 decimals) for a maximum of 10 `EDU` tokens (`u128` value of
`100000000000` as it has 10 decimals).

!Swap Exact Amount

Below is the snapshot of the liquidity pool on the
DOT ACP UI. after successful submission of the
extrinsic above.

!Swap to Exact Amount Example

## Withdraw Provided Liquidity

The `remove_liquidity` function allows users to withdraw their provided liquidity from a pool,
receiving back the original assets. When calling this function, users specify the amount of
liquidity tokens (representing their share in the pool) they wish to burn. They also set minimum
acceptable amounts for the assets they expect to receive back. This mechanism ensures users can
control the minimum value they receive, protecting against unfavourable price movements during the
withdrawal process​.

For example, the snapshot below shows how to remove liquidity by specifying the number of LP tokens.
In exchange of removing around half of the liquidity of the pool, the expecation is that we receive
at least 0.4 `ROC` tokens (`u128` value of`400000000000` as it has 12 decimals) and 40 `EDU` tokens
(`u128` value of `400000000000` as it has 10 decimals).

!Remove Liquidity

Below is the snapshot of the liquidity pool on the
DOT ACP UI. after successful submission of the
extrinsic above.

!Remove Liquidity Example

### Build Integrate Assets

The  Relay Chain does not natively
support assets beyond . This functionality
exists in parachains. On both Polkadot and Kusama, this parachain is called Asset Hub.

The Asset Hub provides a first-class interface for creating, managing, and using fungible and
non-fungible assets. The fungible interface is similar to Ethereum's ERC-20 standard. However, the
data structures and stateful operations are encoded directly into the chain's runtime, making
operations fast and fee-efficient.

Beyond merely supporting assets, integrating an Asset Hub into your systems has several benefits for
infrastructure providers and users:

- Support for on-chain assets.
- Significantly lower transaction fees (about 1/10) than the Relay Chain.
- Significantly lower deposits (1/100) than the Relay Chain. This includes the existential deposit
  and deposits for proxy/multisig operations.
- Ability to pay transaction fees in certain assets. As in, accounts would **not** need DOT to exist
  on-chain or pay fees.

The Asset Hub will use DOT as its native currency. Users can transfer DOT from the Relay Chain into
the Asset Hub and use it natively. The Relay Chain will also accept DOT transfers from the Asset Hub
back to the Relay Chain for staking, governance, or any other activity.

Using the Asset Hub for DOT/KSM balance transfers will be much more efficient than the Relay Chain
and is highly recommended. Until domain-specific parachains are built, the Relay Chain will still
need to be used for staking and governance.

## Assets Basics

See the
Assets pallet for
the most up-to-date info and reference documentation.

Assets are stored as a map from an ID to information about the asset, including a management team,
total supply, total number of accounts, its sufficiency for account existence, and more.
Additionally, the asset owner can register metadata like the name, symbol, and number of decimals
for representation.

Some assets, as determined by on-chain governance, are regarded as “sufficient”. Sufficiency means
that the asset balance is enough to create the account on-chain, with no need for the DOT/KSM
existential deposit. Likewise, you cannot send a non-sufficient asset to an account that does not
exist. Sufficient assets can be used to pay transaction fees (i.e. there is no need to hold DOT/KSM
on the account).

Assets do have a minimum balance (set by the creator), and if an account drops below that balance,
the dust is lost.

### Asset Operations

The Assets pallet has its interface for dealing with assets. See the Integration
section below for how to fetch information and construct transactions.

The main functions you will probably interact with are `transfer` and `transfer_keep_alive`. These
functions transfer some `amount` (balance) of an `AssetId` (a `u32`, not a contract address) to
another account.

The Assets pallet also provides an `approve_transfer`, `cancel_approval`, and `transfer_approved`
interface for non-custodial operations.

Asset transfers will result in an `assets.transferred` event. The same instructions for
monitoring events and **not** transactions applies to asset
transfers.

Note that you can use the same addresses (except
pure proxies!) on the Asset Hub that
you use on the Relay Chain. The SS58 encodings are the same; only the chain information (genesis
hash, etc.) will change on transaction construction.

### Foreign Assets

Foreign assets are those assets in Asset Hub whose native blockchain is not Asset Hub. These are
mainly native tokens from other parachains or bridged tokens from other consensus systems (such as
Ethereum). Once a foreign asset has been registered in Asset Hub (by its root origin), users are
enabled to send this token from its native blockchain to Asset Hub and operate with it as if it were
any other asset.

Practically speaking, foreign assets are handled by the `foreign-assets` pallet in Asset Hub, which
is an instance of the Assets pallet. Hence, this pallet exposes the same interface to users and
other pallets as the Assets pallet.

The main difference to take into account for foreign assets is their identifier. Instead of using
integers as identifiers like in the Assets pallet, assets stored in the `foreign-assets` pallet are
identified by
their XCM multilocation.

## Integration

The Asset Hub will come with the same tooling suite that Parity Technologies provides for the Relay
Chain, namely API Sidecar and
TxWrapper Polkadot,
as well as the Asset Transfer API. If you have a
technical question or issue about how to use one of the integration tools, please file a GitHub
issue so a developer can help.

### Parachain Node

Using the Asset Hub will require running a parachain node to sync the chain. This is very similar to
running a  node, with the addition of
some extra flags. You can follow
these guidelines to set
up an Asset Hub node.

### Asset Transfer API

Asset-transfer-api is a library focused on simplifying the construction of asset transfers for
Substrate-based chains that involve system parachains like Asset Hub (Polkadot and Kusama). It
exposes a reduced set of methods that facilitate users to send transfers to other (para) chains or
locally. You can refer to
this table
for the current cross-chain support and here for
the complete documentation, including installation guide and usage examples.

### Sidecar

API Sidecar is a REST service for Relay Chain and parachain nodes. It comes with endpoints to query
information about assets and asset balances on the Asset Hub.

- Asset lookups always use the `AssetId` to refer to an asset class. On-chain metadata is subject to
  change and thus unsuitable as a canonical index.
- Please refer to docs for full usage
  information. Details on options like how to make a historical query are not included here.

Here are the available public instances:

- Sidecar connected to Polkadot Asset Hub
  and
- Sidecar connected to Kusama Asset Hub

The purpose of these instances is to allow anyone to check and get a quick overview of the info that
the asset-related endpoints provide.

://wiki.polkadot.network/docs/learn-teleport) from
system parachains or with a
Reserve Backed Transfer
from any other parachain. In both cases, the event emitted when processing the transfer is the
`balances.minted` event. Hence, providers should listen to these events, pointing to an address in
their system. For this, the service provider must query every new block created, loop through the
events array, filter for any `balances.minted` event, and apply the appropriate business logic.

#### Tracking back XCM information

What has been mentioned earlier should be sufficient to confirm that
 has arrived in a given account via XCM.
However, in some cases, it may be interesting to identify the cross-chain message that emitted the
relevant `balances.minted` event. This can be done as follows:

1. Query the relevant chain `at` the block the `balances.minted` event was emitted.
2. Filter for a `messageQueue(Processed)` event, also emitted during block initialization. This
   event has a parameter `Id`. The value of `Id` identifies the cross-chain message received in the
   Relay Chain or in the Asset Hub. It can be used to track back the message in the origin parachain
   if needed. Note that a block may contain several `messageQueue(Processed)` events corresponding
   to several cross-chain messages processed for this block.

#### Additional Examples of Monitoring XCM Transfers

The two previous sections outline the process of monitoring XCM deposits to specific account(s) and
then tracing back the origin of these deposits. However, the process of tracking an XCM transfer
(hence the events to look for) may vary based on the direction of the XCM message. Here are some
examples to showcase the slight differences:

1. For an XCM transfer from a Parachain to a Relay chain
   _(example)_:

   - The event to look for in the
     Parachain side is called `parachainsystem (UpwardMessageSent)`, and the parameter
     `message_hash` in this event identifies the XCM transfer.
   - The event to track in
     the Relay chain side is called `messagequeue (Processed)`, and the parameter `id` of the event
     should be the same as the `message_hash` found in the Parachain event.

2. For an XCM transfer from a Relay chain to a Parachain
   _(example)_:

   - The event to look for in
     the Relay chain side is called `xcmPallet (sent)`, and the parameter `message_id` in this event
     identifies the XCM transfer.
   - The event to look for in the
     Parachain side is called `dmpqueue (ExecutedDownward)`, and the parameter that identifies the
     XCM message is either called `message_hash` or `message_id`.

3. For an XCM transfer from a System Parachain to a Parachain
   _(example)_:

   - The event to look
     for in the System Parachain side is called `xcmpqueue (XcmpMessageSent)`, and again the
     `message_hash` is one of the parameters of the event.
   - The corresponding event in
     the Parachain side is the `xcmpqueue (Success)` and the `message_hash` found in that event
     should have the same value as the one in the System parachain.

#### Monitoring of Failed XCM Transfers

In case that an XCM transfer fails to complete successfully, then we will notice some different
parameters in the events emitted or different events. Below are some examples:

1. From a Relay chain to a System Parachain
   _(example)_:

   - We will see the
     event
     `dmpqueue (ExecutedDownward)` in the System Parachain side with the following parameters:
     - `outcome` with value `Incomplete` and with the type of error which in this example is
       UntrustedReserveLocation.
     - `message_id` which shows the hash of the XCM Transfer.

2. From a Parachain to another Parachain
   _(example)_:

   - We will see the event
     `xcmpqueue (Fail)` in the destination Parachain with the following parameters:
     - `error` which in this example is
       TooExpensive.
     - `message_hash` which identifies the XCM Transfer.
   - **Note**: there might be another
     event called
     `polkadotxcm (AssetsTrapped)` which indicates that some assets have been trapped (and hence can
     be claimed).

A great resource to learn more about Error Management in XCM is the Polkadot blog post from Gavin
Wood,
XCM Part III: Execution and Error Management.

## Security Measures

here are code examples that were missing

### Detailed Example Code Snippets

1. **WithdrawAsset Example in Rust**
```rust
use frame_support::{decl_module, dispatch::DispatchResult};
use sp_runtime::traits::AccountIdConversion;

pub trait Config: frame_system::Config {
    type Asset: AssetTransfer<Self::AccountId>;
}

decl_module! {
    pub struct Module<T: Config> for enum Call where origin: T::Origin {
        #[weight = 10_000]
        fn withdraw_asset(origin, asset_id: AssetId, amount: Balance) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            T::Asset::transfer(&sender, &Self::account_id(), asset_id, amount)?;
            Ok(())
        }
    }
}
```

2. **swap_exact_tokens_for_tokens Example in Rust**
```rust
use frame_support::{decl_module, decl_storage, decl_event, dispatch::DispatchResult};
use sp_runtime::traits::AccountIdConversion;

pub trait Config: frame_system::Config {
    type Event: From<Event<Self>> + Into<<Self as frame_system::Config>::Event>;
    type Currency: Currency<Self::AccountId>;
}

decl_storage! {
    trait Store for Module<T: Config> as SwapModule {
        // Storage items here
    }
}

decl_event! {
    pub enum Event<T> where AccountId = <T as frame_system::Config>::AccountId {
        SwapExecuted(AccountId, Balance, Balance),
    }
}

decl_module! {
    pub struct Module<T: Config> for enum Call where origin: T::Origin {
        fn deposit_event() = default;

        #[weight = 10_000]
        fn swap_exact_tokens_for_tokens(origin, amount_in: Balance, amount_out_min: Balance) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            // Swap logic here
            Self::deposit_event(RawEvent::SwapExecuted(sender, amount_in, amount_out_min));
            Ok(())
        }
    }
}
```

3. **Polkadot-JS API Example**
```javascript
// Import the API
const { ApiPromise, WsProvider } = require('@polkadot/api');

// Define the WebSocket endpoint
const wsProvider = new WsProvider('wss://rpc.polkadot.io');

// Create the API instance
async function main() {
    const api = await ApiPromise.create({ provider: wsProvider });

    // Example: Query the balance of an account
    const { data: { free: balance } } = await api.query.system.account('<address>');
    console.log(`Balance: ${balance}`);
}

main().catch(console.error);
```

### Steps to Find More Code Snippets

1. **Identify Key Code Snippets**:
   - Make a list of the specific instructions or functions you need code for. For example, if you are interested in the `WithdrawAsset` or `swap_exact_tokens_for_tokens` functions, note these down.

2. **Utilize Official Resources**:
   - Polkadot-JS API Documentation: Visit the [Polkadot-JS API Documentation](https://polkadot.js.org/docs/) to find code examples related to the API.
   - Polkadot Repository: Explore the [Polkadot GitHub repository](https://github.com/paritytech/polkadot) for the source code.
   - Cumulus Repository: Check the [Cumulus GitHub repository](https://github.com/paritytech/cumulus) for parachain development-related code.
   - Asset Transfer API Documentation: Refer to the asset transfer documentation for examples related to asset transfers.

3. **Search Using Specific Terms**:
   - Use search terms like "WithdrawAsset Polkadot", "swap_exact_tokens_for_tokens Substrate", or "Polkadot XCM examples" to narrow down your search results.

4. **Look at Example Projects**:
   - Explore example projects such as [adder-collator](https://github.com/paritytech/cumulus/tree/master/examples/adder-collator) and [dot-acp-ui](https://github.com/AcalaNetwork/dot-acp-ui) on GitHub. These projects often contain useful snippets and implementation details.

5. **Community Forums**:
   - Participate in Polkadot community forums and discussion groups like [Polkadot's official forum](https://forum.polkadot.network/), [Substrate StackExchange](https://substrate.stackexchange.com/), or relevant [Discord channels](https://discord.gg/polkadot). Developers often share code snippets and solutions.

### Example Searches and Links

1. **WithdrawAsset**:
   - Search: ["WithdrawAsset site:github.com/paritytech"](https://www.google.com/search?q=WithdrawAsset+site%3Agithub.com%2Fparitytech)
   - Example Documentation: [Polkadot XCM Documentation](https://polkadot.js.org/docs/substrate/extrinsics)

2. **swap_exact_tokens_for_tokens**:
   - Search: ["swap_exact_tokens_for_tokens site:github.com/paritytech"](https://www.google.com/search?q=swap_exact_tokens_for_tokens+site%3Agithub.com%2Fparitytech)
   - Example Project: [Uniswap-like Example on Substrate](https://github.com/AcalaNetwork/Acala/tree/master/substrate)

3. **Asset Transfer**:
   - Documentation: [Polkadot Asset Transfer](https://wiki.polkadot.network/docs/learn-assets)
   - Example Project: [Acala Asset Transfer](https://github.com/AcalaNetwork/Acala/tree/master/modules/asset-transfer)

### Conclusion

These snippets and search suggestions should help you find the specific code you need for your Polkadot and Substrate projects. If you have more specific requirements or need additional examples, feel free to ask!
